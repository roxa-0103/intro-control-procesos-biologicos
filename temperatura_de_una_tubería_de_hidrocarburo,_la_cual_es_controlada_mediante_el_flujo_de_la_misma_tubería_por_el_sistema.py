# -*- coding: utf-8 -*-
"""Temperatura de una tubería de hidrocarburo, la cual es controlada mediante el flujo de la misma tubería por el sistema

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lm1Z5PenCFic_gFO7lu-FaLdRSbbyub8
"""

""" CÓDIGO DE CLASE: Ejercicio: Temperatura de una tubería de hidrocarburo, la cual es controlada mediante el flujo de la misma tubería por el sistema"""

# Importar librerías y funciones que se van a emplear
import numpy as np  # librería con funciones útiles
import matplotlib.pyplot as plt  # función para graficar nombrada como plt
from google.colab import drive # Import drive from google.colab

# Montar Drive
drive.mount('/content/drive')

# Leer archivo .txt
data = np.genfromtxt('/content/drive/MyDrive/Colab Notebooks/Datos_t_Op_T Ej. sintonía datos experimentales.txt')


texp = data[:,0]   # vector de tiempo experimental, además del archivo de datos, capture todos los datos con : de la columna 0, osea primera columna
uexp = data[:,1]   # vector de u experimental, flujo normalizado-- 0 % apertura
yexp = data[:,2]   # vector de y experimental, temperatura experimental

# Graficar datos experimentales
plt.figure(1, figsize = (10, 8))  # abrir figura número 1
#plt.show(1)    # sostener la gráfica abierta, para graficar nuevas figuras más abajo en la primera figura NUEVO
plt.subplot(211)
plt.plot(texp, yexp, 'b-', label='Temperatura')  # graficar
plt.title("Temperatura y apertura válvula hidrocarburo submarino")  # título de la gráfica
#plt.xlabel("Tiempo [s]")  # marca eje x
plt.ylabel("Temperatura [°C]")  # marca eje y
plt.grid(True)  # Muestra las divisiones de los ejes
plt.legend(loc='best')


plt.subplot(212)
plt.plot(texp, uexp, 'c-', label='Apertura válvula')  # graficar
plt.title("Apertura flujo hidrocarburo")  # título de la gráfica
plt.xlabel("Tiempo [s]")  # marca eje x
plt.ylabel("Apertura flujo [%]")  # marca eje y
plt.legend(loc='best')
plt.grid(True)  # Muestra las divisiones de los ejes
plt.legend(loc='best')


# Parámetros del modelo empírico de control
Tau = 250  # tiempo de respuesta [h], tiempo del 63% de la variación de la y ó temp.  El cálculo por curva de reacción fue G80
K = 0.5     # Ganancia de la u = deltayexp/deltauxp. El cálculo por curva de reacción fue 0.42

# Vector tiempo que se calcula leyendo los valores experimentales NUEVO
# Recordar que en Python el tamaño del vector está dado por todas las posiciones, sabiendo que
# la primera posición se llama cero y la última posición se llama "tamaño -1", por eso los sgtes comandos

t0_mod = int(texp[0])         # Tiempo inicial [s]  También puede leerse manualmente. Tiempo inicial, osea posición cero "0"
tf_mod = int(texp[len(texp)-1])  # Tiempo final [s]  También puede leerse manualmente
dt = 0.1  # Paso [d]  Cada cuanto tiempo se calcula un punto
iteraciones = round(tf_mod/dt)  # Cantidad de iteraciones o puntos a calcular

tmod = np.linspace(t0_mod, tf_mod, (iteraciones+1))  # (tiempo inicial, tiempo final, número de puntos)

#condiciones iniciales para el modelo
yo_mod=yexp[0] 	#temperatura inicial
uo_mod=uexp[0]

#ecuacion para método de euler
y_mod = np.zeros(iteraciones+1)  #vector para guardar losvalores de cada iteración

# Initialize variables u_mod and y_modnp
#u_mod = np.zeros(len(tmod))
#y_modnp = np.zeros(len(tmod))
#y_mod = yexp[0] # Initialize y_mod with the first experimental temperature value

y=yo_mod
#umod= uo_mod
u_mod = np.zeros(iteraciones+1)


d=4

for i in range(0, iteraciones+1):
    umod = np.interp(tmod[i], texp, uexp)  # NUEVO, interpolación para hacer coincidir el modelo con los datos experimentales

    u_mod[i] = umod
    y_mod[i] = y  # guarda el valor de la temperatura y


    dydt = (-y+K*umod)/Tau+d/Tau  # calcula la derivada de T (o de y)
    y=y+dydt*dt   # Actualiza el valor de la variable según el método de Euler


# Graficar resultados del modelo
plt.subplot(211)
plt.plot(tmod, y_mod, 'r-', label='Temp modelo')  # graficar
plt.legend(loc='best')

plt.subplot(212)
plt.plot(tmod, u_mod, 'r-', label='Apertura modelo') # Add plot for u_mod

plt.legend(loc='best')



from plotly.subplots import make_subplots
fig = make_subplots(cols=1, rows=2, subplot_titles=("Subplot 1", "Subplot 2"))

fig.add_scatter(x=texp, y=yexp, name="línea 1", col=1, row=1)
fig.add_scatter(x=tmod, y=y_mod, name="línea 2", col=1, row=1)

fig.add_scatter(x=texp, y=uexp, name="línea 3", col=1, row=2)
fig.add_scatter(x=tmod, y=yo_mod, name="línea 4", col=1, row=2)

fig.update_yaxes(title_text="eje y - subplot 1", col=1, row=1)
fig.update_xaxes(title_text="eje x - subplot 1", col=1, row=1)

fig.update_yaxes(title_text="eje y - subplot 2", col=1, row=2)
fig.update_xaxes(title_text="eje x - subplot 2", col=1, row=2)


#plt.show()

"""#Optimización numérica#

"""

"""Ejercicio: Temperatura de una tubería de hidrocarburo, la cual es controlada
mediante el flujo de la misma tubería por el sistema"""

# Importar librerías y funciones que se van a emplear
import numpy as np  # librería con funciones útiles
from scipy.optimize import minimize  # librería para optimizar funciones
import matplotlib.pyplot as plt  # función para graficar nombrada como plt
from google.colab import drive # Import drive from google.colab

# Montar Drive
drive.mount("/content/drive", force_remount=True)

# Leer archivo .txt
data = np.genfromtxt('/content/drive/MyDrive/Colab Notebooks/Datos_t_Op_T Ej. sintonía datos experimentales.txt')


t_exp = data[:,0]   # vector de tiempo experimental, además del archivo de datos, capture todos los datos con : de la columna 0, osea primera columna
u_exp = data[:,1]   # vector de u experimental, flujo normalizado--  % apertura
y_exp = data[:,2]   # vector de y experimental, temperatura experimental


##Notese que los parametros se definen en la optimización

#Condición inicial
y_o_mod = y_exp[0] #Temperatura inicial [°C]
t_o_mod= int(t_exp[0]) #Tiempo inicial

t_f_mod= int(t_exp[len(t_exp)-1]) # Tiempo final [min]
dt= 0.1 #paso [min] . cada cuánto tiempo se calcula un punto
iteraciones = round(t_f_mod/dt) #Cantidad de iteraciones o puntos a calcular

t_mod = np.linspace(t_o_mod, t_f_mod, (iteraciones+1)) # (tiempo inicial, tiempo final, numero de puntos) [h]

#Entradas (variables)
u_o_mod = u_exp[0] #Apertura inicial (%)

#vectores para guardar resultados
y_all =np.zeros(iteraciones+1) #vector para guardar los valores de y
u_all =np.zeros(iteraciones+1)  #vector para guardar los valores de u
y_all_interp = np.zeros([len(t_exp)])   #vector para guardar "y" interpolado, vector de ceros del mismo t


#Función objetivo - lo que se va a optmizar (minimizar)
def objetivo(x): # x Es el vector con los valores a optimizar.
    #El vector x contiene los valores de tao y Ku
    tao = x[0] #Primer parámetro a encontrar
    Ku = x[1] #Segundo parámetro a encontrar


    #Valores iniciales para la salida y (entrada)
    y_mod = y_o_mod #asigna el valor inicial de la salida y
    #u_mod = u_o_mod #asigna el valor inicial de la entrada u


    #Método de Euler
    for i in range(0, iteraciones+1):
        u_mod = np.interp(t_mod[i], t_exp, u_exp) #Interpolación u con base en los datos exp.
        u_all[i] = u_mod #guarda el dato de u
        #cálculo de la salida
        y_all[i] = y_mod #guarda el valor de la temperatura
        dydt= (1/tao)*(-y_mod+Ku*u_mod+4) #Calcula la derivada de y (unidades y/ unidades t)
        y_mod = y_mod + dydt*dt #Actualiza el valor de la variable según el método de Euler


    #Interpolación de y simulada respecto a los datos experimentales, aqui se crea un vector con la ymod
    for j in range(0,(int(len(t_exp))-1)):   #va de cero a 601-1=600
        y_interp = np.interp(t_exp[j], t_mod, y_all)
        y_all_interp[j] = y_interp

    error_obj = sum((y_exp-y_all_interp)**2)   #cálculo del error objetivo

    return error_obj  #devuelve el valor calculado


#En ciertas ocaciones puede ser necesario restringir los valores de los parámetros en la optimización mediante condicionales.

#Valores semilla para la optimización - los mismos del método gráfico.
x_0 = np.zeros(2)
x_0[0] = 220 #tau = tiempo de respuesta [min]
x_0[1] = 0.4 #Ku = ganancia [°C/%]


#Mostrar los valores iniciales de parámetros
print("Valor inicial para tao = " + str(x_0[0]))  #str convierte un valor float (real) a un alfanumérico
print("Valor inicial para Ku = " + str(x_0[1]))
print(" valor inicial del error = " + str(objetivo(x_0)))


#Optimización numérica, se minimiza la funcion objetivo (lo que devuelve la función, osea error_obj)
solucion = minimize(objetivo, x_0)
x= solucion.x #jala el valor encontrado en la nueva función "solución"


#mostrar los valores de parámetros Optimizados
print("Valor optimizado para tao = " + str(x[0]))
print("Valor optimizad para Ku = " + str(x[1]))
print("Valor optimizado del error = " + str(objetivo(x)))

"""#Código con zoom#
##CÓDIGO DE CLASE: Ejercicio: Temperatura de una tubería de hidrocarburo, la cual es controlada mediante el flujo de la misma tubería por el sistema##

"""

""" CÓDIGO DE CLASE: Ejercicio: Temperatura de una tubería de hidrocarburo, la cual es controlada mediante el flujo de la misma tubería por el sistema"""

# Importar librerías y funciones que se van a emplear
import numpy as np  # librería con funciones útiles
import matplotlib.pyplot as plt  # función para graficar nombrada como plt
from google.colab import drive # Import drive from google.colab

# Montar Drive
drive.mount('/content/drive')

# Leer archivo .txt
data = np.genfromtxt('/content/drive/MyDrive/Colab Notebooks/Datos_t_Op_T Ej. sintonía datos experimentales.txt')


texp = data[:,0]   # vector de tiempo experimental, además del archivo de datos, capture todos los datos con : de la columna 0, osea primera columna
uexp = data[:,1]   # vector de u experimental, flujo normalizado-- 0 % apertura
yexp = data[:,2]   # vector de y experimental, temperatura experimental

# Graficar datos experimentales
plt.figure(1, figsize = (10, 8))  # abrir figura número 1
#plt.show(1)    # sostener la gráfica abierta, para graficar nuevas figuras más abajo en la primera figura NUEVO
plt.subplot(211)
plt.plot(texp, yexp, 'b-', label='Temperatura')  # graficar
plt.title("Temperatura y apertura válvula hidrocarburo submarino")  # título de la gráfica
#plt.xlabel("Tiempo [s]")  # marca eje x
plt.ylabel("Temperatura [°C]")  # marca eje y
plt.grid(True)  # Muestra las divisiones de los ejes
plt.legend(loc='best')


plt.subplot(212)
plt.plot(texp, uexp, 'c-', label='Apertura válvula')  # graficar
plt.title("Apertura flujo hidrocarburo")  # título de la gráfica
plt.xlabel("Tiempo [s]")  # marca eje x
plt.ylabel("Apertura flujo [%]")  # marca eje y
plt.legend(loc='best')
plt.grid(True)  # Muestra las divisiones de los ejes
plt.legend(loc='best')


# Parámetros del modelo empírico de control
Tau = 250  # tiempo de respuesta [h], tiempo del 63% de la variación de la y ó temp.  El cálculo por curva de reacción fue G80
K = 0.5039     # Ganancia de la u = deltayexp/deltauxp. El cálculo por curva de reacción fue 0.42

# Vector tiempo que se calcula leyendo los valores experimentales NUEVO
# Recordar que en Python el tamaño del vector está dado por todas las posiciones, sabiendo que
# la primera posición se llama cero y la última posición se llama "tamaño -1", por eso los sgtes comandos

t0_mod = int(texp[0])         # Tiempo inicial [s]  También puede leerse manualmente. Tiempo inicial, osea posición cero "0"
tf_mod = int(texp[len(texp)-1])  # Tiempo final [s]  También puede leerse manualmente
dt = 0.1  # Paso [d]  Cada cuanto tiempo se calcula un punto
iteraciones = round(tf_mod/dt)  # Cantidad de iteraciones o puntos a calcular

tmod = np.linspace(t0_mod, tf_mod, (iteraciones+1))  # (tiempo inicial, tiempo final, número de puntos)

#condiciones iniciales para el modelo
yo_mod=yexp[0] 	#temperatura inicial
uo_mod=uexp[0]

#ecuacion para método de euler
y_mod = np.zeros(iteraciones+1)  #vector para guardar losvalores de cada iteración

# Initialize variables u_mod and y_modnp
#u_mod = np.zeros(len(tmod))
#y_modnp = np.zeros(len(tmod))
#y_mod = yexp[0] # Initialize y_mod with the first experimental temperature value

y=yo_mod
#umod= uo_mod
u_mod = np.zeros(iteraciones+1)


d=4

for i in range(0, iteraciones+1):
    umod = np.interp(tmod[i], texp, uexp)  # NUEVO, interpolación para hacer coincidir el modelo con los datos experimentales

    u_mod[i] = umod
    y_mod[i] = y  # guarda el valor de la temperatura y


    dydt = (-y+K*umod)/Tau+d/Tau  # calcula la derivada de T (o de y)
    y=y+dydt*dt   # Actualiza el valor de la variable según el método de Euler


# Graficar resultados del modelo
plt.subplot(211)
plt.plot(tmod, y_mod, 'r-', label='Temp modelo')  # graficar
plt.legend(loc='best')

plt.subplot(212)
plt.plot(tmod, u_mod, 'r-', label='Apertura modelo') # Add plot for u_mod

plt.legend(loc='best')



"""#Lab 2 con datos manuales completos, uniendo los dos cuadros del excel: Caldera#"""

""" CÓDIGO DE CLASE: Caldera"""

# Importar librerías y funciones que se van a emplear
import numpy as np  # librería con funciones útiles
import matplotlib.pyplot as plt  # función para graficar nombrada como plt
from google.colab import drive # Import drive from google.colab

# Montar Drive
drive.mount('/content/drive')

# Leer archivo .txt
data = np.genfromtxt('/content/drive/MyDrive/Colab Notebooks/curva_reaccion_manual_2_caldera.txt', usecols=(0, 1, 2), skip_header=1, invalid_raise=False)


texp = data[:,0]   # vector de tiempo experimental, además del archivo de datos, capture todos los datos con : de la columna 0, osea primera columna
uexp = data[:,1]   # vector de u experimental, flujo normalizado-- 0 % apertura
yexp = data[:,2]   # vector de y experimental, temperatura experimental

#Graficar temperatura
plt.figure(1, figsize = (12, 10))  # abrir figura número 1
plt.subplot(211)
plt.plot(texp, yexp, 'b-', label='Temperatura')  # graficar
plt.title("Temperatura y apertura válvula hidrocarburo submarino")  # título de la gráfica
#plt.xlabel("Tiempo [s]")  # marca eje x
plt.ylabel("Temperatura [°C]")  # marca eje y
plt.grid(True)  # Muestra las divisiones de los ejes
plt.legend(loc='best')
plt.xlim(0, 35)  # Ajustar eje X
plt.ylim(30, 60)

# Marcas cada 0.5 en el eje Y
plt.yticks(np.arange(20, 50.5, 5))

#Graficar apertura
plt.subplot(212)
plt.plot(texp, uexp, 'c-', label='Apertura válvula')  # graficar
plt.title("Apertura de la válvula")  # título de la gráfica
plt.xlabel("Tiempo [s]")  # marca eje x
plt.ylabel("% Apertura")  # marca eje y
plt.legend(loc='best')
plt.grid(True)  # Muestra las divisiones de los ejes
plt.legend(loc='best')

plt.xlim(0, 35)  # Ajustar eje X
plt.ylim(0, 30)  # Ajustar eje y


# Parámetros del modelo empírico de control
Tau = 31  # tiempo de respuesta [h], tiempo del 63% de la variación de la y ó temp.  El cálculo por curva de reacción fue G80
K = 0.42     # Ganancia de la u = deltayexp/deltauxp. El cálculo por curva de reacción fue 0.42

# Vector tiempo que se calcula leyendo los valores experimentales NUEVO
# Recordar que en Python el tamaño del vector está dado por todas las posiciones, sabiendo que
# la primera posición se llama cero y la última posición se llama "tamaño -1", por eso los sgtes comandos

#t0_mod = int(texp[0])         # Tiempo inicial [s]  También puede leerse manualmente. Tiempo inicial, osea posición cero "0"
#tf_mod = int(texp[len(texp)-1])  # Tiempo final [s]  También puede leerse manualmente
#dt = 0.1  # Paso [d]  Cada cuanto tiempo se calcula un punto
#iteraciones = round(tf_mod/dt)  # Cantidad de iteraciones o puntos a calcular

#tmod = np.linspace(t0_mod, tf_mod, (iteraciones+1))  # (tiempo inicial, tiempo final, número de puntos)

#condiciones iniciales para el modelo
#yo_mod=yexp[0]  #temperatura inicial
#uo_mod=uexp[0]

#ecuacion para método de euler
#y_mod = np.zeros(iteraciones+1)  #vector para guardar losvalores de cada iteración

# Initialize variables u_mod and y_modnp
#u_mod = np.zeros(len(tmod))
#y_modnp = np.zeros(len(tmod))
#y_mod = yexp[0] # Initialize y_mod with the first experimental temperature value

#y=yo_mod
#umod= uo_mod
#u_mod = np.zeros(iteraciones+1)


d=4

#for i in range(0, iteraciones+1):
    #umod = np.interp(tmod[i], texp, uexp)  # NUEVO, interpolación para hacer coincidir el modelo con los datos experimentales

    #u_mod[i] = umod
    #y_mod[i] = y  # guarda el valor de la temperatura y


    #dydt = (-y+K*umod)/Tau+d/Tau  # calcula la derivada de T (o de y)
    #y=y+dydt*dt   # Actualiza el valor de la variable según el método de Euler


# Graficar resultados del modelo
plt.subplot(211)
#plt.plot(tmod, y_mod, 'r-', label='Temp modelo')  # graficar
plt.legend(loc='best')

plt.subplot(212)
#plt.plot(tmod, u_mod, 'r-', label='Apertura modelo') # Add plot for u_mod

plt.legend(loc='best')



"""#Lab #2: Caldera, datos manuales: OPTIMIZACIÓN#"""

import numpy as np
import matplotlib.pyplot as plt
import os # Import the os module

# Leer los datos desde archivo .txt
# Ajustamos para que lea las 5 columnas esperadas
file_path = '/content/drive/MyDrive/Colab Notebooks/ Datos_Temp_LAB_3.txt' # Define file_path

# Check if the file exists
if not os.path.exists(file_path):
    print(f"Error: File not found at {file_path}")
else:
    data = np.genfromtxt(file_path, # Use file_path
                         delimiter=',', skip_header=1, invalid_raise=False)

    # Separar las columnas en variables
    tiempo = data[:, 0]
    temperatura = data[:, 1]
    apertura = data[:, 2]
    setpoint = data[:, 3]
    flujo = data[:, 4]

    # --- Gráfico 1: % de apertura vs tiempo ---
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo, apertura, 'g-', label='% Apertura válvula')
    plt.xlabel('Tiempo [min]')
    plt.ylabel('% Apertura')
    plt.title('% de apertura de la válvula en el tiempo')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

    # --- Gráfico 2: Temperatura vs Setpoint ---
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo, temperatura, 'r-', label='Temperatura medida')
    plt.plot(tiempo, setpoint, 'b--', label='Setpoint')
    plt.xlabel('Tiempo [min]')
    plt.ylabel('Temperatura [°C]')
    plt.title('Comparación Temperatura vs Setpoint')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

    # --- Gráfico 3: Flujo vs tiempo ---
    plt.figure(figsize=(10, 4))
    plt.plot(tiempo, flujo, 'm-', label='Flujo (perturbación)')
    plt.xlabel('Tiempo [min]')
    plt.ylabel('Flujo (d)')
    plt.title('Flujo en el tiempo')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()



"""#Modelo fenomenológico: Tanque pulmón"""

## importar librerías
import numpy as np
import matplotlib.pyplot as plt

## Parámetros
Pe = 15           # Presión antes la entrada de la válvula [psig]
D_tanque = 0.3    # diámetro del tanque [m]
H_tanque = 0.805  # altura del tanque [m]
Cv = 0.0016       # coeficiente de la válvula [m^2]
Patm = 12.38      # presión atmosférica [psig]
V = (3.1415*((D_tanque/2)**2))*H_tanque # volumen tanque [m^3]

# Condiciones iniciales
Pv_ent = 5.2           # Presión sobre el vástago de la válvula de entrada [psig]
Pv_sal = 8             # Presión sobre el vástago de la válvula de salida [psig]


##Vector de Tiempo
ti=0 #tiempo inicial (s)
tf=1000 #tiempo final (s)
dt=0.01 #paso s - tiempo que se calcula a x punto
iteraciones=round(tf/dt) #cantidad de iteraciones o puntos a calcular

# Listas para almacenar los resultados de la simulación
t=np.linspace(ti,tf,(iteraciones+1)) #creacion del vector

# Entradas variables
y_o = 0                # valor inicial de la variable controlada [psig]
u_o = 50 #(Pv_ent*100)/15  # valor inicial de la variable manipulada [%]
Pven_o = ((u_o*12)/100)+3
d = Pv_sal    # valor inicial de la perturbación [%]
Pven=Pven_o
#SET POINT
SP_psi = 9  # psig (SET POINT)

## Ecuación de Euler
y_dif= np.zeros(iteraciones+1) #PRESION INICIAL EN EL TANQUE
u_dif=np.zeros(iteraciones+1) #vector de presión dentro de la válvula
Pven_dif = np.zeros(iteraciones+1)
e_dif=np.zeros(iteraciones+1) #vector de error
d_dif=np.zeros(iteraciones+1) #vector de perturbación
SP_psi_dif=np.zeros(iteraciones+1) #vector de set point
sumint = 0

# Constantes
a = 1.1
rho = 0.97 # Kg/m^3

# Asignar valores iniciales a las variables
y = y_o
u = u_o


for i in range(0,iteraciones+1):



    u_dif[i] = u
    y_dif[i] = y
    d_dif[i] = d
    Pven = u*(12/100) + 3
    Pven_dif[i] = Pven
    fxin = abs(a-2.71828**(a-((Pven-3)/12)))
    fxout = abs(a-2.71828**(a-((d-3)/12)))
    Vin = Cv * fxin * np.sqrt((Pe - y)/rho)
    Vout = Cv * fxout * np.sqrt((y)/rho)
    dydt = ((1/V)*(Pe+Patm)*Vin) - ((1/V)*(y+Patm)*Vout)

    y = y + dydt * dt

#Gráfica
plt.figure(1)
plt.subplot(411)
plt.title("Control de presión")
plt.plot(t,y_dif,"r-", label = "Presión en el tanque")
plt.ylabel("y [psig]")
plt.xlabel("tiempo [s]")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

#PID


# importar librerías
import numpy as np
import matplotlib.pyplot as plt

# Parámetros
Pe = 15           # Presión antes la entrada de la válvula [psig]
D_tanque = 0.3    # diámetro del tanque [m]
H_tanque = 0.805  # altura del tanque [m]
Cv = 0.0016       # coeficiente de la válvula [m^2]
Patm = 85326.32       # presión atmosférica [Pa]
V = (3.1415*((D_tanque/2)**2))*H_tanque  # volumen tanque [m^3]

# Condiciones iniciales
# Presión sobre el vástago de la válvula de entrada [psig]
Pv_ent = 5.2
# Presión sobre el vástago de la válvula de salida [psig]
Pv_sal = 8


# Vector de Tiempo
ti = 0  # tiempo inicial (s)
tf = 2000  # tiempo final (s)
dt = 0.01  # paso s - tiempo que se calcula a x punto
iteraciones = round(tf/dt)  # cantidad de iteraciones o puntos a calcular

# Listas para almacenar los resultados de la simulación
t = np.linspace(ti, tf, (iteraciones+1))  # creacion del vector

# Entradas variables
y_o = 0                # valor inicial de la variable controlada [psig]
u_o = 50  # (Pv_ent*100)/15  # valor inicial de la variable manipulada [%]
Pven_o = ((u_o*12)/100)+3
d = Pv_sal    # valor inicial de la perturbación [%]
Pven = Pven_o
# SET POINT
SP_psi = 9  # psig (SET POINT)

# Ecuación de Euler
y_dif = np.zeros(iteraciones+1)  # PRESION INICIAL EN EL TANQUE
u_dif = np.zeros(iteraciones+1)  # vector de presión dentro de la válvula
Pven_dif = np.zeros(iteraciones+1)
e_dif = np.zeros(iteraciones+1)  # vector de error
d_dif = np.zeros(iteraciones+1)  # vector de perturbación
SP_psi_dif = np.zeros(iteraciones+1)  # vector de set point
sumint = 0

# Constantes
a = 1.1
rho = 0.97  # Kg/m^3

# Asignar valores iniciales a las variables
y = y_o
u = u_o

# Parámetros de control
Ku = -2  # [%/%]
Tao = 4  # Tiempo de respuesta [s]
Kp = (0.6*Ku) * 25  # Constante proporcional de control [%/%]
Ki = (1.2*(Ku/Tao)) * 3  # Constante integral de control [%/(%*s)]
Kd = (0.075*Ku*Tao) * 0  # Costante derivativa de control [%/(%*s)]


for i in range(0, iteraciones+1):

    if t[i] <= 360:  # (segundos)
        d = 0
    if t[i] > 360 and t[i] <= 720:  # (segundos)
        d = 12
    if t[i] > 720:  # (segundos)
        d = 5

    u_dif[i] = u
    y_dif[i] = y
    d_dif[i] = d
    Pven = u*(12/100) + 3
    Pven_dif[i] = Pven
    fxin = np.abs(a-np.exp(a-(Pven-3)/12))
    fxout = np.abs(a-np.exp(a-(d-3)/12))
    Vin = Cv*fxin*np.sqrt((Pe-y)/rho)
    Vout = Cv*fxout*np.sqrt((y)/rho)
    dydt = ((1/V)*(Pe+Patm)*Vin) - ((1/V)*(y+Patm)*Vout)

    y = y + dydt * dt

    e = (((SP_psi) - (y))-3)*100/12
    e_dif[i] = e*(12/100) + 3
    SP_psi_dif[i] = SP_psi

    sumint = sumint + e*dt
    if i >= 1:
        de_dt = (e_dif[i]-e_dif[i-1])/dt
    else:
        de_dt = 0

    u = Kp*e + (Ki)*sumint + (Kd)*de_dt

    if u > 100:
        u = 100
    if u < 0:
        u = 0

# Gráfica
plt.figure(1)
plt.subplot(411)
plt.title("Control de presión")
plt.plot(t, y_dif, "r-", label="Y")
plt.plot(t, SP_psi_dif, "b--", label="Ysp")
plt.ylabel("y [psig]")
plt.legend()
plt.grid(True)

plt.subplot(412)
plt.plot(t, u_dif, "g-", label="Variable manipulada")
plt.ylabel("u %")
plt.legend()
plt.grid(True)

plt.subplot(414)
plt.plot(t, e_dif, "b-", label="Error")
plt.xlabel("tiempo [s]")
plt.ylabel("e [psig]")
plt.legend()
plt.grid(True)

plt.subplot(413)
plt.plot(t, d_dif, "y-", label="Perturbación")
plt.ylabel("d [psig]")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# codigo sin perturbacion control p sin sintonizar
import numpy as np
import matplotlib.pyplot as plt

## Parámetros
Pe = 15           # Presión antes la entrada de la válvula [psig]
D_tanque = 0.3    # diámetro del tanque [m]
H_tanque = 0.805  # altura del tanque [m]
Cv = 0.0016       # coeficiente de la válvula [m^2]
Patm = 12.38      # presión atmosférica [psig]
V = (3.1415*((D_tanque/2)**2))*H_tanque # volumen tanque [m^3]

# Condiciones iniciales
Pv_ent = 5.2           # Presión sobre el vástago de la válvula de entrada [psig]
Pv_sal = 8             # Presión sobre el vástago de la válvula de salida [psig]


## Vector de Tiempo
ti = 0  # tiempo inicial (s)
tf = 2000  # tiempo final (s)
dt = 0.01  # paso s - tiempo que se calcula a x punto
iteraciones = round(tf/dt)  # cantidad de iteraciones o puntos a calcular

# Listas para almacenar los resultados de la simulación
t = np.linspace(ti, tf, (iteraciones+1))  # creación del vector

# Entradas variables
y_o = 0                # valor inicial de la variable controlada [psig]
u_o = 50 #(Pv_ent*100)/15  # valor inicial de la variable manipulada [%]
Pven_o = ((u_o*12)/100)+3
d = Pv_sal    # valor inicial de la perturbación [%]
Pven = Pven_o
# SET POINT
SP_psi = 9  # psig (SET POINT)

## Ecuación de Euler
y_dif = np.zeros(iteraciones+1)  # PRESION INICIAL EN EL TANQUE
u_dif = np.zeros(iteraciones+1)  # vector de presión dentro de la válvula
Pven_dif = np.zeros(iteraciones+1)
e_dif = np.zeros(iteraciones+1)  # vector de error
d_dif = np.zeros(iteraciones+1)  # vector de perturbación
SP_psi_dif = np.zeros(iteraciones+1)  # vector de set point
sumint = 0

# Constantes
a = 1.1
rho = 0.97  # Kg/m^3

# Asignar valores iniciales a las variables
y = y_o
u = u_o

## Parámetros de control
Ku = -2  # [%/%]
Tao = 4  # Tiempo de respuesta [s]
Kp = (0.5*Ku)       # Constante proporcional de control [%/%]
# Ki = (1.2*(Ku/Tao)) # Constante integral de control [%/(%*s)]
# Kd= (0.075*Ku*Tao) # Costante derivativa de control [%/(%*s)]


for i in range(0, iteraciones+1):
    if t[i] < 200:
        u = 50
    else:
        u = 15

    # if t[i] <= 360: #(segundos)
    #     d = 0
    # if t[i] > 360 and t[i] <= 720: #(segundos)
    #     d = 12
    # if t[i] > 720:  #(segundos)
    #     d = 5

    u_dif[i] = u
    y_dif[i] = y
    d_dif[i] = d
    Pven = u*(12/100) + 3
    Pven_dif[i] = Pven
    fxin = np.abs(a-np.exp(a-(Pven-3)/12))
    fxout = np.abs(a-np.exp(a-(d-3)/12))
    Vin = Cv*fxin*np.sqrt((Pe-y)/rho)
    Vout = Cv*fxout*np.sqrt((y)/rho)
    dydt = ((1/V)*(Pe+Patm)*Vin) - ((1/V)*(y+Patm)*Vout)

    y = y + dydt * dt

    e = (((SP_psi) - (y))-3)*100/12
    e_dif[i] = e*(12/100) + 3
    SP_psi_dif[i] = SP_psi

    u = Kp*e

    if u > 100:
        u = 100
    if u < 0:
        u = 0

# Gráfica
plt.figure(1)
plt.subplot(411)
plt.title("Control de presión")
plt.plot(t, y_dif, "r-", label="Y")
plt.plot(t, SP_psi_dif, "b--", label="Ysp")
plt.ylabel("y [psig]")
plt.legend()
plt.grid(True)

plt.subplot(412)
plt.plot(t, u_dif, "g-", label="Variable manipulada")
plt.ylabel("u %")
plt.legend()
plt.grid(True)

plt.subplot(414)
plt.plot(t, e_dif, "b-", label="Error")
plt.xlabel("tiempo [s]")
plt.ylabel("e [psig]")
plt.legend()
plt.grid(True)

plt.subplot(413)
plt.plot(t, d_dif, "y-", label="Perturbación")
plt.ylabel("d [psig]")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

# Control de presión en tanque pulmón de aire comprimido

import numpy as np
import matplotlib.pyplot as plt

# === Parámetros físicos del sistema ===
Pe = 15           # Presión de entrada a la válvula [psig]
D_tanque = 0.3    # Diámetro del tanque [m]
H_tanque = 0.805  # Altura del tanque [m]
Cv = 0.0016       # Coeficiente de la válvula [m²]
Patm = 85326.32   # Presión atmosférica [Pa]
a = 1.1           # Constante empírica para fx
rho = 0.97        # Densidad del aire [kg/m³]

# === Cálculo del volumen del tanque [m³] ===
V = np.pi * (D_tanque / 2)**2 * H_tanque

# === Condiciones iniciales ===
Pv_ent = 5.2      # Presión sobre vástago válvula de entrada [psig]
Pv_sal = 8        # Presión sobre vástago válvula de salida [psig]
SP_psi = 9        # Set point de presión dentro del tanque [psig]

# === Tiempo de simulación ===
ti, tf, dt = 0, 2000, 0.01
iteraciones = round((tf - ti) / dt)
t = np.linspace(ti, tf, iteraciones + 1)

# === Vectores para guardar resultados ===
y_dif = np.zeros(iteraciones + 1)  # presión del tanque [psig]
u_dif = np.zeros(iteraciones + 1)  # señal de control [%]
Pven_dif = np.zeros(iteraciones + 1)  # presión vástago entrada [psig]
e_dif = np.zeros(iteraciones + 1)
d_dif = np.zeros(iteraciones + 1)
SP_psi_dif = np.zeros(iteraciones + 1)

# === Inicialización ===
y = 0       # presión inicial en tanque [psig]
u = 50      # apertura inicial [%]
sumint = 0

# === PID (Ziegler-Nichols ajustado manualmente) ===
Ku = -2
Tao = 4
Kp = 0.6 * Ku * 25
Ki = 1.2 * (Ku / Tao) * 3
Kd = 0.075 * Ku * Tao * 0

# === Simulación ===
for i in range(iteraciones + 1):
    # --- Perturbación en válvula de salida (d) ---
    if t[i] <= 360:
        d = 0
    elif t[i] <= 720:
        d = 12
    else:
        d = 5
    d_dif[i] = d

    # --- Actualizar presión del vástago entrada en función de u [%] ---
    Pven = (u * 12 / 100) + 3  # de 3 a 15 psig
    Pven_dif[i] = Pven

    # --- fx para entrada y salida ---
    fxin = np.abs(a - np.exp(a - (Pven - 3)/12))
    fxout = np.abs(a - np.exp(a - (d - 3)/12))

    # --- Presión real (absoluta) dentro del tanque [Pa] ---
    P_abs = y * 6894.76 + Patm  # convertir psig a Pa
    Pe_abs = Pe * 6894.76 + Patm  # presión absoluta de entrada [Pa]

    # --- Flujo volumétrico entrada y salida ---
    Vin = Cv * fxin * np.sqrt((Pe_abs - P_abs) / rho)
    Vout = Cv * fxout * np.sqrt((P_abs - Patm) / rho)

    # --- Derivada de presión (modelo físico) ---
    dP_dt = ((Pe_abs * Vin) - (P_abs * Vout)) / V
    dP_dt_psig = dP_dt / 6894.76  # convertir a psig/s

    # --- Integración Euler para presión del tanque ---
    y += dP_dt_psig * dt
    y_dif[i] = y

    # --- Cálculo del error y PID ---
    e = SP_psi - y  # error en psig
    e_dif[i] = e
    SP_psi_dif[i] = SP_psi
    sumint += e * dt

    if i > 0:
        de_dt = (e_dif[i] - e_dif[i - 1]) / dt
    else:
        de_dt = 0

    u = Kp * e + Ki * sumint + Kd * de_dt

    # --- Saturación de u ---
    u = max(0, min(100, u))
    u_dif[i] = u

# === Gráficas ===
plt.figure(figsize=(10, 8))
plt.subplot(411)
plt.plot(t, y_dif, 'r-', label='Presión en el tanque')
plt.plot(t, SP_psi_dif, 'b--', label='Set Point')
plt.ylabel("Presión [psig]")
plt.legend()
plt.grid(True)
plt.title("Control de presión en tanque pulmón")

plt.subplot(412)
plt.plot(t, u_dif, 'g-', label='Apertura válvula entrada')
plt.ylabel("u [%]")
plt.legend()
plt.grid(True)

plt.subplot(413)
plt.plot(t, d_dif, 'y-', label='Perturbación (válvula salida)')
plt.ylabel("d [psig]")
plt.legend()
plt.grid(True)

plt.subplot(414)
plt.plot(t, e_dif, 'b-', label='Error')
plt.xlabel("Tiempo [s]")
plt.ylabel("e [psig]")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

"""#LAB 3: TEMPERATURA"""

import pandas as pd
import matplotlib.pyplot as plt
import os

# Leer archivo CSV (ajusta el nombre y ruta si es diferente)
# Si el separador decimal es coma, usa: decimal=','
file_path = '/content/drive/MyDrive/Colab Notebooks/curva_reaccion_manual_1_caldera.txt'

# Check if the file exists
if not os.path.exists(file_path):
    print(f"Error: File not found at {file_path}")
else:
    df = pd.read_csv(file_path)

    # Renombrar columnas if necessary (adjust to your actual file)
    # Assuming the order is 'Tiempo', 'Temperatura', 'Apertura', 'Setpoint', 'Flujo'
    df.columns = ['Tiempo', 'Temperatura', 'Apertura', 'Setpoint', 'Flujo']

    # --- Gráfico 1: % de apertura vs tiempo ---
    plt.figure(figsize=(10, 4))
    plt.plot(df['Tiempo'], df['Apertura'], 'g-', label='% Apertura válvula')
    plt.xlabel('Tiempo [min]')
    plt.ylabel('% Apertura')
    plt.title('% de apertura de la válvula en el tiempo')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

    # --- Gráfico 2: Temperatura vs Setpoint ---
    plt.figure(figsize=(10, 4))
    plt.plot(df['Tiempo'], df['Temperatura'], 'r-', label='Temperatura medida')
    plt.plot(df['Tiempo'], df['Setpoint'], 'b--', label='Setpoint')
    plt.xlabel('Tiempo [min]')
    plt.ylabel('Temperatura [°C]')
    plt.title('Comparación Temperatura vs Setpoint')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

    # --- Gráfico 3: Flujo vs tiempo ---
    plt.figure(figsize=(10, 4))
    plt.plot(df['Tiempo'], df['Flujo'], 'm-', label='Flujo (perturbación)')
    plt.xlabel('Tiempo [min]')
    plt.ylabel('Flujo (d)')
    plt.title('Flujo en el tiempo')
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()

"""#Caldera control PID#"""

import pandas as pd
import matplotlib.pyplot as plt
from google.colab import drive

# 1) Monta Drive (solo la primera vez pon force_remount=True)
drive.mount('/content/drive')

# 2) Carga y convierte a numérico
ruta = '/content/drive/MyDrive/Colab Notebooks/Datos_Temp_LAB_3.txt'
cols = ['Tiempo','Temperatura','Apertura_ini','Setpoint','Flujo']
df = pd.read_csv(ruta, sep=r'\s+', skiprows=1, names=cols)
for c in ['Temperatura','Apertura_ini','Flujo','Setpoint']:
    df[c] = df[c].astype(str).str.replace(',','.').astype(float)

# 3) Clase PID
class PID:
    def __init__(self, kp, ki, kd, dt):
        self.kp,self.ki,self.kd,self.dt = kp,ki,kd,dt
        self.I=0; self.e_prev=0
    def update(self,e):
        P = self.kp*e
        self.I += e*self.dt
        I = self.ki*self.I
        D = self.kd*(e-self.e_prev)/self.dt
        self.e_prev = e
        return max(0,min(100,P+I+D))

# 4) Bucle PID
Kp,Ki,Kd = 2.0,0.5,0.1
dt = df['Tiempo'].diff().median()
pid = PID(Kp,Ki,Kd,dt)
df['PID_Apertura'] = [(pid.update(sp - tm))
                      for tm,sp in zip(df['Temperatura'],df['Setpoint'])]

# 5) Gráficas
plt.figure(figsize=(10,4))
plt.plot(df['Tiempo'],df['Temperatura'],label='Temperatura medida')
plt.plot(df['Tiempo'],df['Setpoint'],'--',label='Setpoint')
plt.xlabel('Tiempo [min]'); plt.ylabel('Temp [°C]')
plt.legend(); plt.grid(True)

plt.figure(figsize=(10,3))
plt.plot(df['Tiempo'],df['PID_Apertura'],label='Apertura PID')
plt.xlabel('Tiempo [min]'); plt.ylabel('Apertura [%]')
plt.ylim(0,110); plt.grid(True)

plt.show()

"""#Segundo código control PID Temperatura"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from google.colab import drive # Import drive from google.colab
import pandas as pd # Import pandas

# === 1. Leer datos ===


# Montar Drive
drive.mount('/content/drive')

# Leer archivo .txt using pandas
ruta = '/content/drive/MyDrive/Colab Notebooks/Datos_Temp_LAB_3.txt'
cols = ['Tiempo','Temperatura','Apertura_ini','Setpoint','Flujo']
df = pd.read_csv(ruta, sep=r'\s+', skiprows=1, names=cols)

# Convertir letras a números
for c in ['Temperatura','Apertura_ini','Flujo','Setpoint']:
    df[c] = df[c].astype(str).str.replace(',','.').astype(float)


t_exp  = df['Tiempo'].values   # tiempo [min]
y_exp  = df['Temperatura'].values   # Temperatura [°C]
u_exp  = df['Apertura_ini'].values   # % Apertura (sólo para identificación)
y_setp = df['Setpoint'].values   # Setpoint [°C]
d      = df['Flujo'].values   # Perturbaciones

# === 2. Condiciones iniciales de integración ===
y_o_mod = y_exp[0]
t_o_mod = t_exp[0]
t_f_mod = t_exp[-1]
dt      = 0.1
t_mod   = np.arange(t_o_mod, t_f_mod + dt, dt)
N       = len(t_mod)

# === 3. Función objetivo (identifica τ y Kᵤ) ===
def objetivo(x):
    tau, Ku = x
    y = y_o_mod
    y_all = np.zeros(N)
    for i in range(N):
        # usamos u_exp para ajustar el modelo
        u_model = np.interp(t_mod[i], t_exp, u_exp)
        dy      = (1/tau)*(-y + Ku*u_model)
        y      += dy*dt
        y_all[i] = y
    # comparamos solo en tiempos experimentales
    y_interp = np.interp(t_exp, t_mod, y_all)
    return np.sum((y_exp - y_interp)**2)

x0     = [10, 0.4]
bounds = [(1e-3, None), (1e-3, None)]
sol    = minimize(objetivo, x0, bounds=bounds)
tau_opt, Ku_opt = sol.x

# === 4. Definir clase PID ===
class PID:
    def __init__(self, kp, ki, kd, dt):
        self.kp, self.ki, self.kd, self.dt = kp, ki, kd, dt
        self.I = 0.0
        self.e_prev = 0.0
    def update(self, e):
        P = self.kp * e
        self.I += e * self.dt
        I = self.ki * self.I
        D = self.kd * (e - self.e_prev) / self.dt
        self.e_prev = e
        u = P + I + D
        # satúa entre 0% y 100%
        return max(0, min(100, u))

# === 5. Simulación con PID cerrado ===
# Parámetros de controlador (ajustar)
Kp, Ki, Kd = 2.0, 0.5, 0.1
pid = PID(Kp, Ki, Kd, dt)

y     = y_o_mod
y_all = np.zeros(N)
u_all = np.zeros(N)

# Necesitamos el setpoint en cada dt:
sp_all = np.interp(t_mod, t_exp, y_setp)
d_all = np.interp(t_mod, t_exp, d) #Interpolar perturbación

for i in range(N):
    e        = sp_all[i] - y
    u_ctrl   = pid.update(e)
    #Añade perturbación al modelo
    dydt     = (1/tau_opt)*(-y + Ku_opt * u_ctrl + d_all[i]) # Add perturbation term
    y       += dydt * dt
    y_all[i] = y
    u_all[i] = u_ctrl

# === 6. Gráficas ===
plt.figure(figsize=(8,4))
plt.plot(t_mod,   y_all, 'b-', label='Simulación con PID')
plt.plot(t_mod, sp_all, 'g--', label='Setpoint')
plt.xlabel('Tiempo [min]')
plt.ylabel('Temperatura [°C]')
plt.title('Respuesta en lazo cerrado (PID)')
plt.legend()
plt.grid(True)

plt.figure(figsize=(8,3))
plt.plot(t_mod, u_all, 'r-', label='Señal PID (% apertura)')
plt.xlabel('Tiempo [min]')
plt.ylabel('Apertura válvula [%]')
plt.title('Acción de control PID')
plt.ylim(0,110)
plt.grid(True)

plt.tight_layout()
plt.show()



"""#TERCER CÓDIGO CONTROL TEMPERATURA#"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import drive

# === 1) Montar Drive y leer datos ===
drive.mount('/content/drive', force_remount=True)
ruta = '/content/drive/MyDrive/Colab Notebooks/Datos_Temp_LAB_3.txt'
cols = ['Tiempo','Temperatura','Apertura_ini','Setpoint','Flujo']
df = pd.read_csv(ruta, sep=r'\s+', skiprows=1, names=cols)

# Convert relevant columns to numeric, handling potential commas as decimal separators
for c in ['Tiempo', 'Temperatura', 'Apertura_ini', 'Setpoint', 'Flujo']:
    df[c] = df[c].astype(str).str.replace(',','.').astype(float)


# Extraemos arrays de numpy
t_exp  = df['Tiempo'].values      # [min]
y_exp  = df['Temperatura'].values # [°C] (solo para inicializar)
sp_exp = df['Setpoint'].values    # [°C]
d_exp  = df['Flujo'].values       # perturbación (m3/min)

# === 2) Parámetros del modelo de 1er orden ===
tau = 12.0    # tiempo muerto del sistema [min]
Ku  = 0.4     # ganancia del proceso [°C / %apertura]

# === 3) Parámetros del PID ===
Kp = 6.0      # ganancia proporcional
Ki = 1.0      # ganancia integral  (1/min)
Kd = 0.5      # ganancia derivativa [min]

# === 4) Preparar simulación ===
dt    = 0.1                                # paso de integración [min]
t_sim = np.arange(t_exp[0], t_exp[-1]+dt, dt)
N     = len(t_sim)

# Arreglos para almacenar resultados
y_sim = np.zeros(N)
u_sim = np.zeros(N)
sp_sim = np.interp(t_sim, t_exp, sp_exp)
d_sim  = np.interp(t_sim, t_exp, d_exp)

# Condición inicial
y_sim[0] = y_exp[0]

# Variables internas del PID
integral = 0.0
e_prev   = sp_sim[0] - y_sim[0]

# === 5) Bucle de simulación lazo cerrado ===
for i in range(1, N):
    # Error actual
    error = sp_sim[i] - y_sim[i-1]

    # Proporcional
    P = Kp * error

    # Integral (con anti-windup opcional)
    integral += error * dt
    I = Ki * integral

    # Derivativo
    D = Kd * (error - e_prev) / dt
    e_prev = error

    # Señal PID no saturada
    u = P + I + D

    # Saturación entre 0% y 100%
    u = np.clip(u, 0, 100)
    u_sim[i] = u

    # Modelo de primer orden con perturbación d_sim
    dy = ( - y_sim[i-1] + Ku * u + d_sim[i] ) / tau
    y_sim[i] = y_sim[i-1] + dy * dt

# === 6) Gráficas ===
plt.figure(figsize=(10,4))
plt.plot(t_sim,   y_sim, 'b-', label='Temperatura simulada')
plt.plot(t_sim, sp_sim, 'g--', label='Setpoint')
plt.xlabel('Tiempo [min]')
plt.ylabel('Temperatura [°C]')
plt.title('Respuesta en Lazo Cerrado con Control PID')
plt.legend()
plt.grid(True)

plt.figure(figsize=(10,3))
plt.plot(t_sim, u_sim, 'r-', label='Señal PID (% apertura)')
plt.xlabel('Tiempo [min]')
plt.ylabel('Apertura válvula [%]')
plt.title('Acción de Control PID')
plt.ylim(0,110)
plt.grid(True)

plt.tight_layout()
plt.show()

"""#Curva de reacción: CALDERA"""

import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt
from google.colab import drive

# Montar Google Drive
drive.mount("/content/drive", force_remount=True)

# Leer archivo de datos
data = np.genfromtxt('/content/drive/MyDrive/Colab Notebooks/curva_reaccion_manual_1_caldera.txt',
                     usecols=(0, 1, 2), skip_header=1, invalid_raise=False)

# Extraer columnas
t_exp = data[:, 0]
u_exp = data[:, 1]
y_exp = data[:, 2]

# Condiciones iniciales
d = 36.75
y_o_mod = y_exp[0]
u_o_mod = u_exp[0]
t_o_mod = int(t_exp[0])
t_f_mod = int(t_exp[-1])
dt = 0.5
iteraciones = round(t_f_mod / dt)  #cuántas veces se calcula
t_mod = np.linspace(t_o_mod, t_f_mod, iteraciones + 1)

# Vectores para almacenar resultados
y_all = np.zeros(iteraciones + 1)  #guarda los valores de temperatura simulada que genera el modelo, paso a paso
u_all = np.zeros(iteraciones + 1)  #guarda los valores de apertura de válvula interpolada en cada t_mod
y_all_interp = np.zeros(len(t_exp))  #se llena con los valores simulados de y, pero alineados a los tiempos experimentales t_exp (usando interpolación)

# Valores iniciales Tao y Ku, respectivamente
x_0 = [12, 0.4]

# Función objetivo con modelo desplazado (evita caída inicial)
def objetivo(x):
    tao = x[0]
    Ku = x[1]
    y_mod = y_o_mod # Inicializa y_mod with the initial experimental value

    for i in range(iteraciones + 1):
        u_mod = np.interp(t_mod[i], t_exp, u_exp)
        u_all[i] = u_mod # Store interpolated u_mod
        dydt = (-y_mod+Ku*u_mod)/tao +(d/tao)   # calcula la derivada de T (o de y) ELIMINÉ EL +D
        y_mod = y_mod + dydt*dt   # Actualiza el valor de la variable según el método de Euler

        y_all[i] = y_mod  # guarda el valor de la temperatura y


    for j in range(len(t_exp)):
        y_interp = np.interp(t_exp[j], t_mod, y_all)
        y_all_interp[j] = y_interp

    error_obj = sum((y_exp - y_all_interp) ** 2)
    return error_obj



print("Valor inicial para tao =", round(x_0[0],3))
print("Valor inicial para Ku =", round(x_0[1],3))
print("Valor inicial del error =", round(objetivo(x_0),3))

# Optimización con límites
bounds = [(1, 100), (0.01, 2)] #Impone un rango permitido para cada valor
solucion = minimize(objetivo, x_0, bounds=bounds)  #Busca los mejores valores de tao y Ku que minimizan el error.
x = solucion.x

print("Valor optimizado para tao =", round(x[0],2))
print("Valor optimizado para Ku =", round(x[1],3))
print("Valor optimizado del error =", round(objetivo(x),3))

# Ejecutar simulación final
objetivo(x)

# Gráficas

plt.figure(1, figsize=(10, 8), facecolor='lightgray')


# Panel 1: Temperatura experimental + simulada
plt.subplot(2, 1, 1)

#plt.figure(figsize=(10, 5))
plt.plot(t_exp, y_exp, 'r', label='Temperatura experimental')
plt.plot(t_mod, y_all, 'b-', label='Temperatura simulada')
plt.xlabel('Tiempo [min]')
plt.ylabel('Temperatura [°C]')
plt.title("Curvas de reacción")
plt.xlabel("Tiempo [min]")
plt.ylabel("Temperatura [°C]")
plt.legend()
plt.grid(True)


# Panel 1: Apertura (u)
plt.subplot(2, 1, 2)
plt.plot(t_mod, u_all, 'k-', label='% Apertura válvula')
plt.title("Variable manipulada (u)")
plt.xlabel("Tiempo [min]")
plt.ylabel("% Apertura válvula")

plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()



"""#Cuarto código control PID CALDERA"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from google.colab import drive

# === 1. Lectura de datos experimentales ===
drive.mount('/content/drive')
ruta = '/content/drive/MyDrive/Colab Notebooks/Datos_Temp_LAB_3.txt'
cols = ['Tiempo', 'Temperatura', 'Apertura_ini', 'Setpoint', 'Flujo']
df = pd.read_csv(ruta, sep=r'\s+', skiprows=1, names=cols)

# Convert relevant columns to numeric, handling potential commas as decimal separators
for c in ['Tiempo', 'Temperatura', 'Apertura_ini', 'Setpoint', 'Flujo']:
    df[c] = df[c].astype(str).str.replace(',', '.').astype(float)

t_exp = df['Tiempo'].values
y_exp = df['Temperatura'].values
u_exp = df['Apertura_ini'].values
setp  = df['Setpoint'].values
d_exp = df['Flujo'].values

# === 2. Parámetros del proceso ===
# Use the optimized values provided by the user
Tau_process = 5.887517405763902
K_process   = 0.3954417758228035

# Cálculo de dt
dt_array = np.diff(t_exp)
if not np.allclose(dt_array, dt_array[0]):
    print("¡Atención! Paso de tiempo variable, usando media.")
dt = dt_array.mean()

# === 3. Ziegler–Nichols (tus valores) ===
# Use the optimized values for Z-N calculation
K_u = K_process
T_u = Tau_process

# Fórmulas Z–N for PID clásico
Kp = K_u * 0.6
Ki = (1.2 * K_u) / T_u
Kd = (3.0 * K_u * T_u) / 40.0


# Límites de la señal de control
u_min, u_max = 0.0, 100.0  # [% apertura]

# === 4. Preparación de vectores ===
n = len(t_exp)
y_sim = np.zeros(n)
u_sim = np.zeros(n)
e     = np.zeros(n)
I_term   = 0.0
prev_err = 0.0

# Condición inicial
y_sim[0] = y_exp[0]
u_sim[0] = u_exp[0]

# === 5. Simulación paso a paso (Euler + PID) ===
for i in range(1, n):
    sp = setp[i]
    d  = d_exp[i]

    # Error
    e[i] = sp - y_sim[i-1]

    # Integral
    I_term += e[i] * dt

    # Derivada
    D_term = (e[i] - prev_err) / dt

    # Ley PID
    u = Kp * e[i] + Ki * I_term + Kd * D_term

    # Saturación
    u = np.clip(u, u_min, u_max)
    u_sim[i] = u

    # Dinámica del proceso (Euler)
    dy = (-y_sim[i-1] + K_process * u + d) / Tau_process
    y_sim[i] = y_sim[i-1] + dy * dt

    prev_err = e[i]

# === 6. Gráficos de resultados ===

# 6.1. Respuesta sin control vs PID vs setpoint
plt.figure(figsize=(8,4))
plt.plot(t_exp, y_exp,   'k.', label='Sistema Experimental (Sin Control)')
plt.plot(t_exp, y_sim,  'b-', label='Sistema con Control PID')
plt.plot(t_exp, setp,   'r--', label='Setpoint')
plt.xlabel('Tiempo [s]')
plt.ylabel('Temperatura [°C]')
plt.title('Comparación: Sistema Experimental vs. Control PID vs. Setpoint')
plt.legend()
plt.grid(True)

# 6.2. Perturbación y respuesta controlada
plt.figure(figsize=(8,4))
plt.plot(t_exp, d_exp, 'm-', label='Perturbación (Flujo)')
plt.plot(t_exp, y_sim, 'b-', label='Temperatura con Control PID')
plt.xlabel('Tiempo [s]')
plt.ylabel('Magnitud')
plt.title('Efecto de la Perturbación en la Temperatura (con Control PID)')
plt.legend()
plt.grid(True)

plt.show()

"""#CÓDIGO FINAL TEMPERATURA"""

#Sistema de control de temperatura. Laboratorio 3. Curva de Temperatura

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

#datos
data = np.genfromtxt("/content/drive/MyDrive/Colab Notebooks/Datos_Temp_LAB_3_.txt", skip_header=1)
t_exp = data[:, 0]          # tiempo [min]
y_exp = data[:, 1]          # Temperatura [°C]
u_exp = data[:, 2]          # % Apertura
y_setp = data[:, 3]         # Setpoint [°C]
d = data[:, 4]              # Perturbaciones

#Condiciones iniciales
y_o_mod = y_exp[0]
t_o_mod = t_exp[0]
t_f_mod = t_exp[-1]
dt = 0.1
t_mod = np.arange(t_o_mod, t_f_mod + dt, dt)
iteraciones = len(t_mod)

#Interpola u_exp to match t_mod
u_exp_interp = np.interp(t_mod, t_exp, u_exp)


#Función objetivo
def objetivo(x):
    tau, Ku = x
    y_mod = y_o_mod
    y_all = np.zeros(iteraciones)

    for i in range(iteraciones):
        # Use the interpolated u_exp_interp
        u_model = u_exp_interp[i]
        dydt = (1 / tau) * (-y_mod + Ku * u_model)
        y_mod += dydt * dt
        y_all[i] = y_mod

    y_interp = np.interp(t_exp, t_mod, y_all)
    error = np.sum((y_exp - y_interp) ** 2)
    return error

#Optimización
x_0 = [10, 0.4]
bounds = [(1e-3, None), (1e-3, None)]

print("Valores iniciales:")
print(f"τ = {x_0[0]}  Ku = {x_0[1]}  Error = {objetivo(x_0):.4f}")

solucion = minimize(objetivo, x_0, bounds=bounds)
tau_opt, Ku_opt = solucion.x
error_opt = objetivo(solucion.x)

print("\nValores optimizados:")
print(f"τ = {tau_opt:.3f}")
print(f"Ku = {Ku_opt:.3f}")
print(f"Error = {error_opt:.4f}")

#Simulación con parámetros óptimos
y_mod = y_o_mod
y_all = np.zeros(iteraciones)

for i in range(iteraciones):
    # Use the interpolated u_exp_interp
    u_model = u_exp_interp[i]
    dydt = (1 / tau_opt) * (-y_mod + Ku_opt * u_model)
    y_mod += dydt * dt
    y_all[i] = y_mod

y_all_interp = np.interp(t_exp, t_mod, y_all)

#Interpolar el setpoint a t_mod si es necessario
y_setp_interp = np.interp(t_mod, t_exp, y_setp)

#Gráfica
plt.figure(1)
plt.plot(t_exp, y_exp, 'r', label='Temperatura experimental (y)')

plt.plot(t_mod, u_exp_interp, 'g--', label='% Apertura de la válvula (u)')
plt.xlabel('Tiempo [min]',fontsize=11)
plt.ylabel('Temperatura [°C]',fontsize=11)
plt.title('Sistema de control de Temperatura (Caldera)')
plt.legend()
plt.grid(True)
plt.xlim(0, 55)  # Limitar el tiempo a 60 min


plt.figure(2)
plt.plot(t_exp, y_exp, 'r', label='Temperatura experimental')
plt.plot(t_mod, y_all, 'b-', label='Temperatura simulada')

plt.plot(t_mod, u_exp_interp, 'g--', label='% Apertura de la válvula')
plt.xlabel('Tiempo [min]',fontsize=11)
plt.ylabel('Temperatura [°C]',fontsize=11)
plt.title('Sistema de control de Temperatura (Caldera)')
plt.legend()
plt.grid(True)
plt.xlim(0, 55)  # Limitar el tiempo a 60 min

plt.figure(3)
plt.plot(t_exp, y_exp, 'r', label='Temperatura experimental (y)')
plt.plot(t_mod, u_exp_interp, 'g--', label='% Apertura de la válvula (u)')
#plt.plot(t_mod, y_all, 'b-', label='Temperatura simulada')
plt.plot(t_mod, y_setp_interp, 'b-', label='Set Point')
plt.xlabel('Tiempo [min]',fontsize=11)
plt.ylabel('Temperatura [°C]',fontsize=11)
plt.title('Sistema de control de Temperatura (Caldera)')
plt.legend()
plt.grid(True)
plt.xlim(0, 55)  # Limitar el tiempo a 60 min


plt.figure(4)
plt.subplot(211)
# Interpolate u_exp for plotting
plt.plot(t_mod, u_exp_interp,'m-',linewidth=1.5) # Graficar u
plt.title("% Apertura")
plt.xlabel('Tiempo [min]')
plt.ylabel('% Apertura válvula',fontsize=11)
plt.grid(True) # Muestra las divisiones de los ejes
plt.subplots_adjust(hspace=2) # Crea un espacio entre los páneles

plt.subplot(212)
# Interpolate d for plotting
d_interp = np.interp(t_mod, t_exp, d)
plt.plot(t_mod, d_interp,'c-',linewidth=1.5) # Graficar d
plt.title("Perturbación (d)")
plt.xlabel('Tiempo [min]')
plt.ylabel('Flujo W ent ($\\dfrac{L}{min}$)', fontsize=11)
plt.grid(True) # Muestra las divisiones de los ejes\
plt.xlim(0, 55)
plt.subplots_adjust(hspace=2) # Crea un espacio entre los páneles

plt.tight_layout()
plt.show()

"""#Código Final"""

#Sistema de control de temperatura. Laboratorio 3. Curva de Temperatura

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from google.colab import drive # Import drive
import pandas as pd # Import pandas
import os # Import os

# Mount Google Drive
drive.mount('/content/drive')

#datos
file_path = "/content/drive/MyDrive/Colab Notebooks/Datos_Temp_LAB_3.txt"

# Check if file exists before attempting to read
if not os.path.exists(file_path):
    print(f"Error: File not found at {file_path}")
else:
    # Read data using pandas, handling potential commas and spaces
    df = pd.read_csv(file_path, sep=r'\s+', skiprows=1, names=['Tiempo', 'Temperatura', 'Apertura_ini', 'Setpoint', 'Flujo'])

    # Convert relevant columns to numeric, handling potential commas as decimal separators
    for col in ['Tiempo', 'Temperatura', 'Apertura_ini', 'Setpoint', 'Flujo']:
        df[col] = df[col].astype(str).str.replace(',', '.').astype(float)

    t_exp = df['Tiempo'].values          # tiempo [min]
    y_exp = df['Temperatura'].values          # Temperatura [°C]
    u_exp = df['Apertura_ini'].values          # % Apertura
    y_setp = df['Setpoint'].values         # Setpoint [°C]
    d = df['Flujo'].values              # Perturbaciones

    #Condiciones iniciales
    y_o_mod = y_exp[0]
    t_o_mod = t_exp[0]
    t_f_mod = t_exp[-1]
    dt = 0.1
    t_mod = np.arange(t_o_mod, t_f_mod + dt, dt)
    iteraciones = len(t_mod)

    #Interpola u_exp to match t_mod
    u_exp_interp = np.interp(t_mod, t_exp, u_exp)


    #Función objetivo
    def objetivo(x):
        tau, Ku = x
        y_mod = y_o_mod
        y_all = np.zeros(iteraciones)

        for i in range(iteraciones):
            # Use the interpolated u_exp_interp
            u_model = u_exp_interp[i]
            dydt = (1 / tau) * (-y_mod + Ku * u_model)
            y_mod += dydt * dt
            y_all[i] = y_mod

        y_interp = np.interp(t_exp, t_mod, y_all)
        error = np.sum((y_exp - y_interp) ** 2)
        return error

    #Optimización
    x_0 = [10, 0.4]
    bounds = [(1e-3, None), (1e-3, None)]

    print("Valores iniciales:")
    print(f"τ = {x_0[0]}  Ku = {x_0[1]}  Error = {objetivo(x_0):.4f}")

    solucion = minimize(objetivo, x_0, bounds=bounds)
    tau_opt, Ku_opt = solucion.x
    error_opt = objetivo(solucion.x)

    print("\nValores optimizados:")
    print(f"τ = {tau_opt:.3f}")
    print(f"Ku = {Ku_opt:.3f}")
    print(f"Error = {error_opt:.4f}")

    #Simulación con parámetros óptimos
    y_mod = y_o_mod
    y_all = np.zeros(iteraciones)

    for i in range(iteraciones):
        # Use the interpolated u_exp_interp
        u_model = u_exp_interp[i]
        dydt = (1 / tau_opt) * (-y_mod + Ku_opt * u_model)
        y_mod += dydt * dt
        y_all[i] = y_mod

    y_all_interp = np.interp(t_exp, t_mod, y_all)

    #Interpolar el setpoint a t_mod si es necessario
    y_setp_interp = np.interp(t_mod, t_exp, y_setp)

    #Gráficas
    plt.figure(1)
    plt.figure(figsize=(8, 10))

    # Panel 1: Temperatura experimental y Set Point
    plt.subplot(3, 1, 1)
    plt.plot(t_exp, y_exp, 'r', label='y [°C]')
    plt.plot(t_mod, y_setp_interp, 'g--', label='ysp [°C]') #Graficar el Set Point
    plt.title('Temperatura (y) y Set Point')   # Título propio
    plt.ylabel('Temp. experimental [°C]', fontsize=11)
    plt.legend()
    plt.grid(True)
    plt.xlim(0, 55)

    # Panel 2: % Apertura de válvula
    plt.subplot(3, 1, 2)

    plt.plot(t_mod, u_exp_interp, 'b-', label='u [%]')
    #plt.plot(t_mod, y_setp_interp, 'g--', label='Set Point')
      # rango de 0 a 100%
    #plt.yticks(np.linspace(0, 100, 6))  # opcional: 0,20,40,60,80,100
    #plt.gca().yaxis.set_major_formatter(PercentFormatter(xmax=100))
    plt.title('Temperatura (y) y Apertura de la válvula (u)')
    plt.ylabel('% Apertura', fontsize=11)
    plt.legend()
    plt.grid(True)
    plt.xlim(0, 55)


    # Panel 3: Perturbación
    plt.subplot(3, 1, 3)
    d_interp = np.interp(t_mod, t_exp, d)
    plt.plot(t_mod, d_interp, 'm-', label='d [L/min]')
    plt.title('Temperatura (y) y Perturbación (d)')
    plt.ylabel('Flujo W ent (L/min)', fontsize=11)
    plt.legend()
    plt.grid(True)
    plt.xlim(0, 55)



    plt.tight_layout()
    plt.show()
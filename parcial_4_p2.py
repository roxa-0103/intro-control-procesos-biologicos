# -*- coding: utf-8 -*-
"""Parcial #4_P2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EyC89z3WU2URmj4rInWubfWcX6FnIDmS

#Make zoom in the plot#
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install mpl_interactions

import numpy as np
from scipy.integrate import solve_ivp
import plotly.graph_objects as go

# Parámetros y funciones del modelo...
mu_max, K_s, K_o, C_star, Y_xs, m_s = 0.5, 1.0, 0.2, 8.0, 0.5, 0.01
k_s, k_e = 0.05, 0.01
K1, K2, K3, n = 0.1, 0.01, 0.05, 2.5
F1, F2, t_step = 1.0, 2.0, 5.0

def F_air_t(t):
    return F1 if t < t_step else F2

def reactor_odes(t, y):
    Xv, Xs, S, Cdo = y
    mu = mu_max * S/(K_s + S) * Cdo/(K_o + Cdo)
    dXv = (mu - k_s - k_e) * Xv
    dXs = k_s * Xv
    dS  = - (mu/Y_xs + m_s) * Xv
    Fa = F_air_t(t)
    kLa = K3 * Fa**n
    OTR = kLa * (C_star - Cdo)
    OUR = K1 * dXv + K2 * Xv
    dCdo = OTR - OUR
    return [dXv, dXs, dS, dCdo]

# Simulación
y0 = [0.1, 0.0, 20.0, 1.0]
t_span = (0, 20)
t_eval = np.linspace(*t_span, 500)
sol = solve_ivp(reactor_odes, t_span, y0, t_eval=t_eval)

t, Cdo = sol.t, sol.y[3]
F_t = np.array([F_air_t(tt) for tt in t])

# Crear figura Plotly
fig = go.Figure()

# Subplot para O₂ disuelto
fig.add_trace(go.Scatter(x=t, y=Cdo, mode='lines', name='O₂ disuelto (mg/L)',
                         line=dict(color='green')))

# Subplot para flujo de aire (uso de eje y secundario)
fig.add_trace(go.Scatter(x=t, y=F_t, mode='lines', name='Flujo de aire (L/min)',
                         line=dict(color='purple'), yaxis='y2'))

# Configurar layouts y ejes
fig.update_layout(
    title='Respuesta de Cₙₙ al escalón en Fₐₐₙᵣₑ',
    xaxis=dict(title='Tiempo (h)', domain=[0, 0.95]),
    yaxis=dict(title='O₂ disuelto (mg/L)', side='left'),
    yaxis2=dict(title='Flujo de aire (L/min)', overlaying='y', side='right'),
    legend=dict(x=0.85, y=0.95),
    hovermode='x unified',
    width=800, height=500
)

# Habilita zoom, pan automáticamente
fig.show()

"""#1.1 Dinámica Biorreactor_Cod.2"""

# 1. Importar todas las librerias y funciones que se necesitan
# ------------------------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
import math
import plotly.graph_objects as go
from plotly.subplots import make_subplots


# ------------------------------------------------------------------------------
# 2. Parámetros del proceso
# ------------------------------------------------------------------------------
F_air_in = 1320 # Flujo de aire que entra al bioreactor [L/h]
DO2_sat = 7.59e-3 # Conc. de saturación de oxigeno disuelto [g O2/L]
K1 = 3.795e-3 # Constante de consumo de O2 para crecimiento [Adimensional]
K2 = 0.729e-3 # Constante de consumo de O2 para mantenimiento [1/h]
K3 = 2.114e-3 # Constante de ventilación [1/L]
V = 11 # Volumen de trabajo del biorreactor [L]
vvm = (F_air_in/V)/60 # Volumen de aire por volumen de medio por minuto [1/min]
Ko = 1e-4 # Constante de saturación para oxígeno [g oxígeno/L]

# ------------------------------------------------------------------------------
# 3. Condiciones iniciales
# ------------------------------------------------------------------------------

Xv_o = 1 # Células vegetativas [g celulas/L]
Xs_o = 0 # Células esporuladas [g esporas/L]
S_o = 32 # Sustrato [g sustrato/L]
DO2_o = 7.4e-3 # Oxígeno disuelto [g oxígeno/L]

# ------------------------------------------------------------------------------
# 4. Otros parámetros necesarios
# ------------------------------------------------------------------------------
mu_max = 0.65 # Máxima velocidad de crecimiento[h^-1]
Yxs = 0.37   # Rendimiento de biomasa respecto al sustrato [gx/gs]
Ks = 3       #Constante cinética que representa la formación de esporas [h^-1]
ms = 0.005   #Constante de mantenimiento celular [gs*h/gx]
Ks_max = 0.5 #Constante cinética máxima [h^-1]
Gs = 1       #Constante para la tasa de formación de esporas [gxs/L]
Ps = 1       #Constante de posición para la tasa de formación de espora [gxs/L]
Ke_max = 0.1 #Tasa máxima específica de muerte celular [h^-1]
Ge = 5       #Constante para la tasa específica de muerte celular [h^-1]
Pe = 4.9     #Constante de posición para la tasa específica de muerte celular [h^-1]

# ------------------------------------------------------------------------------
# 5. Vector tiempo
# ------------------------------------------------------------------------------
t_0 = 0 		  # Tiemo incial [h]
t_f = 20 	  # Tiempo final [h]
dt = 0.001 	  # Tamaño de Paso [h]
iteraciones = round(t_f/dt) # Cantidad de iteraciones
t = np.linspace(t_0, t_f, (iteraciones+1))

# ------------------------------------------------------------------------------
## 6. Vectores
# ------------------------------------------------------------------------------
mu_dif = np.zeros(iteraciones+1)
Xv_dif = np.zeros(iteraciones+1)
Xs_dif = np.zeros(iteraciones+1)
S_dif = np.zeros(iteraciones+1)
Fair_dif = np.zeros(iteraciones+1)
OD2_dif = np.zeros(iteraciones+1)
Ke_dif = np.zeros(iteraciones+1)
Ks_dif = np.zeros(iteraciones+1)

# ------------------------------------------------------------------------------
## 7. Ecuación diferencial (método de Euler)
# ------------------------------------------------------------------------------
Xv = Xv_o
Xs = Xs_o
S = S_o
CDO = DO2_o

for i in range(0, iteraciones+1):

  mu = (mu_max)*((S/(Ks+S))*(CDO/(Ko+CDO))) # Ecuación velocidad del crecimiento celular
  mu_dif[i] = mu

  Ks = Ks_max*(1/(1+np.exp(Gs*(S-Ps))))-Ks_max*(1/(1+np.exp(Gs*(S_o-Ps))))
  Ks_dif[i] = Ks
  Ke = Ke_max*(1/(1+np.exp(Ge*(t[i]-Pe))))-Ke_max*(1/(1+np.exp(Ge*(t_0-Pe))))
  Ke_dif[i] = Ke

  dXv_dt = (mu-Ks-Ke)*Xv # Ecuación células vegetativas
  dXs_dt = Ks*Xv         # Ecuación células esporuladas
  dSdt = -((mu/Yxs)+ms)*Xv # Ecuación para el sustrato

  OTR = K3*F_air_in*(DO2_sat-CDO)
  OUT = K1*(mu-Ke)*Xv + K2*(Xv+Xs)
  dCDO_dt = (OTR-OUT)

  CDO = CDO + dCDO_dt*dt
  Xs = Xs + dXs_dt*dt
  Xv = Xv + dXv_dt*dt
  S = S + dSdt*dt

  Xv_dif[i] = Xv
  Xs_dif[i] = Xs
  S_dif[i] = S
  OD2_dif[i] = CDO
  Fair_dif[i] = F_air_in
# ------------------------------------------------------------------------------
# 8. Graficar los resultados con zoom
# ------------------------------------------------------------------------------
# Crear subplots (4 filas, 1 columna)
fig = make_subplots(
    rows=4, cols=1, shared_xaxes=True,
    vertical_spacing=0.05,
    subplot_titles=[
        "Biomasa: Células vegetativas y esporuladas",
        "Sustrato",
        "Oxígeno disuelto",
        "Flujo de aire"
    ]
)

# Parte 1: Biomasa
fig.add_trace(go.Scatter(x=t, y=Xv_dif, name='Xv (vegetativas)', line=dict(color='magenta')), row=1, col=1)
fig.add_trace(go.Scatter(x=t, y=Xs_dif, name='Xs (esporuladas)', line=dict(color='green')), row=1, col=1)

# Parte 2: Sustrato
fig.add_trace(go.Scatter(x=t, y=S_dif, name='Sustrato', line=dict(color='yellow')), row=2, col=1)

# Parte 3: Oxígeno disuelto
fig.add_trace(go.Scatter(x=t, y=OD2_dif, name='O₂ disuelto', line=dict(color='cyan')), row=3, col=1)

# Parte 4: Flujo de aire
fig.add_trace(go.Scatter(x=t, y=Fair_dif, name='Flujo de aire', line=dict(color='blue')), row=4, col=1)

# Layout general
fig.update_layout(
    height=1000, width=900,
    title_text="Dinámica de oxígeno en un biorreactor con B. thuringiensis",
    showlegend=True,
    hovermode="x unified"
)

# Etiquetas de ejes
fig.update_xaxes(title_text="Tiempo [h]", row=4, col=1)
fig.update_yaxes(title_text="Biomasa [g/L]", row=1, col=1)
fig.update_yaxes(title_text="Sustrato [g/L]", row=2, col=1)
fig.update_yaxes(title_text="Oxígeno disuelto [g/L]", row=3, col=1)
fig.update_yaxes(title_text="Aire [L/h]", row=4, col=1)

"""#Curva de Reacción#"""

# 1. Importar todas las librerias y funciones que se necesitan
# ------------------------------------------------------------------------------
import numpy as np
import matplotlib.pyplot as plt
import math
from scipy.integrate import solve_ivp
import plotly.graph_objects as go
from plotly.subplots import make_subplots

# ------------------------------------------------------------------------------
# 2. Parámetros del proceso
# ------------------------------------------------------------------------------
F_air_in = 1320 # Flujo de aire que entra al bioreactor [L/h]
DO2_sat = 7.59e-3 # Conc. de saturación de oxigeno disuelto [g O2/L]
K1 = 3.795e-3 # Constante de consumo de O2 para crecimiento [Adimensional]
K2 = 0.729e-3 # Constante de consumo de O2 para mantenimiento [1/h]
K3 = 2.114e-3 # Constante de ventilación [1/L]
V = 11 # Volumen de trabajo del biorreactor [L]
vvm = (F_air_in/V)/60 # Volumen de aire por volumen de medio por minuto [1/min]
Ko = 1e-4 # Constante de saturación para oxígeno [g oxígeno/L]

# ------------------------------------------------------------------------------
# 3. Condiciones iniciales
# ------------------------------------------------------------------------------
Xv_o = 1 # Células vegetativas [g celulas/L]
Xs_o = 0 # Células esporuladas [g esporas/L]
S_o = 32 # Sustrato [g sustrato/L]
DO2_o = 7.4e-3 # Oxígeno disuelto [g oxígeno/L]

# ------------------------------------------------------------------------------
# 4. Otros parámetros necesarios
# ------------------------------------------------------------------------------
mu_max = 0.65 # Máxima velocidad de crecimiento[h^-1]
Yxs = 0.37   # Rendimiento de biomasa respecto al sustrato [gx/gs]
Ks = 3       #Constante cinética que representa la formación de esporas [h^-1]
ms = 0.005   #Constante de mantenimiento celular [gs*h/gx]
Ks_max = 0.5 #Constante cinética máxima [h^-1]
Gs = 1       #Constante para la tasa de formación de esporas [gxs/L]
Ps = 1       #Constante de posición para la tasa de formación de espora [gxs/L]
Ke_max = 0.1 #Tasa máxima específica de muerte celular [h^-1]
Ge = 5       #Constante para la tasa específica de muerte celular [h^-1]
Pe = 4.9     #Constante de posición para la tasa específica de muerte celular [h^-1]

# ------------------------------------------------------------------------------
# 5. Vector tiempo
# ------------------------------------------------------------------------------
t_0 = 0                   # Tiemo incial [h]
t_f = 30          # Tiempo final [h]
dt = 0.001        # Tamaño de Paso [h]
iteraciones = round(t_f/dt) # Cantidad de iteraciones
t = np.linspace(t_0, t_f, (iteraciones+1))

# ------------------------------------------------------------------------------
## 6. Vectores
# ------------------------------------------------------------------------------
mu_dif = np.zeros(iteraciones+1)
Xv_dif = np.zeros(iteraciones+1)
Xs_dif = np.zeros(iteraciones+1)
S_dif = np.zeros(iteraciones+1)
Fair_dif = np.zeros(iteraciones+1)
OD2_dif = np.zeros(iteraciones+1)
Ke_dif = np.zeros(iteraciones+1)
Ks_dif = np.zeros(iteraciones+1)

# ------------------------------------------------------------------------------
## 7. Ecuación diferencial (método de Euler)
# ------------------------------------------------------------------------------
Xv = Xv_o
Xs = Xs_o
S = S_o
CDO = DO2_o
Fair = F_air_in

for i in range(0, iteraciones+1):
  if t[i]>= 15:
    Fair = 1800

  mu = (mu_max)*((S/(Ks+S))*(CDO/(Ko+CDO))) # Ecuación velocidad del crecimiento celular
  mu_dif[i] = mu

  Ks = Ks_max*(1/(1+np.exp(Gs*(S-Ps))))-Ks_max*(1/(1+np.exp(Gs*(S_o-Ps))))
  Ks_dif[i] = Ks
  Ke = Ke_max*(1/(1+np.exp(Ge*(t[i]-Pe))))-Ke_max*(1/(1+np.exp(Ge*(t_0-Pe))))
  Ke_dif[i] = Ke

  dXv_dt = (mu-Ks-Ke)*Xv # Ecuación células vegetativas
  dXs_dt = Ks*Xv         # Ecuación células esporuladas
  dSdt = -((mu/Yxs)+ms)*Xv # Ecuación para el sustrato

  OTR = K3*Fair*(DO2_sat-CDO)
  OUT = K1*(mu-Ke)*Xv + K2*(Xv+Xs)
  dCDO_dt = (OTR-OUT)

  CDO = CDO + dCDO_dt*dt
  Xs = Xs + dXs_dt*dt
  Xv = Xv + dXv_dt*dt
  S = S + dSdt*dt

  Xv_dif[i] = Xv
  Xs_dif[i] = Xs
  S_dif[i] = S
  OD2_dif[i] = CDO
  Fair_dif[i] = Fair
# ------------------------------------------------------------------------------
# 8. Graficar los resultados
# ------------------------------------------------------------------------------
plt.figure(1,figsize=(10,8), facecolor='lightgray')

# Crear subplots (4 filas, 1 columna)
fig = make_subplots(
    rows=4, cols=1, shared_xaxes=True,
    vertical_spacing=0.05,
    subplot_titles=[
        "Biomasa (Xv y Xs)",
        "Sustrato (S)",
        "Oxígeno disuelto (O₂)",
        "Flujo de aire (F_air)"
    ]
)

# Parte 1: Biomasa
fig.add_trace(go.Scatter(x=t, y=Xv_dif, name='Xv (vegetativas)', line=dict(color='magenta')), row=1, col=1)
fig.add_trace(go.Scatter(x=t, y=Xs_dif, name='Xs (esporuladas)', line=dict(color='green')), row=1, col=1)

# Parte 2: Sustrato
fig.add_trace(go.Scatter(x=t, y=S_dif, name='Sustrato', line=dict(color='yellow')), row=2, col=1)

# Parte 3: Oxígeno
fig.add_trace(go.Scatter(x=t, y=OD2_dif, name='O₂ disuelto', line=dict(color='cyan')), row=3, col=1)

# Parte 4: Aire
fig.add_trace(go.Scatter(x=t, y=Fair_dif, name='Flujo de aire', line=dict(color='blue')), row=4, col=1)

# Layout
fig.update_layout(
    height=900, width=850,
    title_text="Dinámica de oxígeno en un biorreactor con B. thuringiensis",
    showlegend=True,
    hovermode="x unified"
)

# Ejes
fig.update_xaxes(title_text="Tiempo [h]", row=4, col=1)
fig.update_yaxes(title_text="Biomasa [g/L]", row=1, col=1)
fig.update_yaxes(title_text="Sustrato [g/L]", row=2, col=1)
fig.update_yaxes(title_text="Oxígeno disuelto [g/L]", row=3, col=1)
fig.update_yaxes(title_text="Aire [L/h]", row=4, col=1)

fig.show()

"""#Cálculo Ku y Tao

A partir de la curva de reacción experimental, se realizaron los pasos del método gráfico y se obtuvieron los siguientes parámetros:

>Ku = deltay / delta u = (0.00436-0.00316)/(1800-1320)= 0.0012/480 = 2.5^10-6

>0.632*0.0012 =  0.000758 + 0.0032 = 0.0039584

Se le suma 0.0032 ya que allí ae ubica el estado estacionario

>Tiempo = 15.29

>t_0.063= 15.29-15 = 0.29 = Tao

Se resta 15 debido a que allí inicia el escalón

#Linealización#

Se comienza a linealizar bajo el **valor óptimo de operación**


1.   Importamos la librería sympy as sp
2.   Declaramos todas las variables del proceso como un objeto symbols:
variable1, variable2 = sp.symbols("variable1 variable2")
3. Creo un vector "ff" = todas las ecuaciones diferenciales:
ff =sp.Matrix([V_i, bla, bla,])
4. Creo un vector Y con las variables de salida:
Y = sp.Matrix([X, P, S])
5. Luego, en otro vector, diferente, vamos a almacenar nuevamente las variables de estado zz = sp.Matrix([X, P, S])
6. Creo un vector u para la variable de entrada: u= sp.Matrix([f_j])

A partir de esto, calculamos el Jacobiano de la matriz ff para cada uno, es decir
1. La matriz A = ff.jacobian(x_s) jacobiano de todas las ecuaciones respecto a las variables de *estado*
2. La matriz B = ff.jacobian(u)  jacobiano de todas las ecuaciones respecto a las variables de *entrada*
3. Jacobiano de las variables de salida respecto a cada una de ellas:
C = Y.jacobian(x_s)
D = Y.jacobian(u)


Ahora, vamos a reemplazar esos valores en estado estacionario ya que alrededor de estos es que vamos a linealizar y eso lo hacemos con (foto 2)

Luego, se convierte la matriz de sympy a un array de numpy (foto 3)

 Para asegurarnos que vamos bien, calculamos los valores propios de la matriz A y verificamos que todos sean negativos (foto 4)

** --> Nos vamos a Matlab para calcular las funciones de transferencia del sistema**
"""



"""#Matrices#"""

import numpy as np
import matplotlib.pyplot as plt
import math
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import sympy as sp


# ------------------------------------------------------------------------------
#Parámetros del proceso
# ------------------------------------------------------------------------------
F_air_in = 1320 # Flujo de aire que entra al bioreactor [L/h]
DO2_sat = 7.59e-3 # Conc. de saturación de oxigeno disuelto [g O2/L]
K1 = 3.795e-3 # Constante de consumo de O2 para crecimiento [Adimensional]
K2 = 0.729e-3 # Constante de consumo de O2 para mantenimiento [1/h]
K3 = 2.114e-3 # Constante de ventilación [1/L]
V = 11 # Volumen de trabajo del biorreactor [L]
vvm = (F_air_in/V)/60 # Volumen de aire por volumen de medio por minuto [1/min]
Ko = 1e-4 # Constante de saturación para oxígeno [g oxígeno/L]


#Condiciones iniciales

Xv_o = 1 # Células vegetativas [g celulas/L]
Xs_o = 0 # Células esporuladas [g esporas/L]
S_o = 32 # Sustrato [g sustrato/L]
DO2_o = 7.4e-3 # Oxígeno disuelto [g oxígeno/L]


#Otros parámetros necesarios

mu_max = 0.65 # Máxima velocidad de crecimiento[h^-1]
Yxs = 0.37   # Rendimiento de biomasa respecto al sustrato [gx/gs]
Ks = 3       #Constante cinética que representa la formación de esporas [h^-1]
ms = 0.005   #Constante de mantenimiento celular [gs*h/gx]
Ks_max = 0.5 #Constante cinética máxima [h^-1]
Gs = 1       #Constante para la tasa de formación de esporas [gxs/L]
Ps = 1       #Constante de posición para la tasa de formación de espora [gxs/L]
Ke_max = 0.1 #Tasa máxima específica de muerte celular [h^-1]
Ge = 5       #Constante para la tasa específica de muerte celular [h^-1]
Pe = 4.9     #Constante de posición para la tasa específica de muerte celular [h^-1]


#Vector tiempo
t_0 = 0 		  # Tiemo incial [h]
t_f = 20 	  # Tiempo final [h]
dt = 0.001 	  # Tamaño de Paso [h]
iteraciones = round(t_f/dt) # Cantidad de iteraciones
t = np.linspace(t_0, t_f, (iteraciones+1))


#Vectores
mu_dif = np.zeros(iteraciones+1)
Xv_dif = np.zeros(iteraciones+1)
Xs_dif = np.zeros(iteraciones+1)
S_dif = np.zeros(iteraciones+1)
Fair_dif = np.zeros(iteraciones+1)
OD2_dif = np.zeros(iteraciones+1)
Ke_dif = np.zeros(iteraciones+1)
Ks_dif = np.zeros(iteraciones+1)


#Ecuación diferencial (método de Euler)

Xv = Xv_o
Xs = Xs_o
S = S_o
CDO = DO2_o


for i in range(0, iteraciones+1):

  mu = (mu_max)*((S/(Ks+S))*(CDO/(Ko+CDO))) # Ecuación velocidad del crecimiento celular
  mu_dif[i] = mu

  Ks = Ks_max*(1/(1+np.exp(Gs*(S-Ps))))-Ks_max*(1/(1+np.exp(Gs*(S_o-Ps))))
  Ks_dif[i] = Ks
  Ke = Ke_max*(1/(1+np.exp(Ge*(t[i]-Pe))))-Ke_max*(1/(1+np.exp(Ge*(t_0-Pe))))
  Ke_dif[i] = Ke

  dXv_dt = (mu-Ks-Ke)*Xv # Ecuación células vegetativas
  dXs_dt = Ks*Xv         # Ecuación células esporuladas
  dSdt = -((mu/Yxs)+ms)*Xv # Ecuación para el sustrato

  OTR = K3*F_air_in*(DO2_sat-CDO)
  OUT = K1*(mu-Ke)*Xv + K2*(Xv+Xs)
  dCDO_dt = (OTR-OUT)

  CDO = CDO + dCDO_dt*dt
  Xs = Xs + dXs_dt*dt
  Xv = Xv + dXv_dt*dt
  S = S + dSdt*dt

  Xv_dif[i] = Xv
  Xs_dif[i] = Xs
  S_dif[i] = S
  OD2_dif[i] = CDO
  Fair_dif[i] = F_air_in


#-------------------------------------------------------------------------------------
#Pasos del vídeo

#Xv, Xs, S, DO2 = sp.symbols("Xv Xs S DO2")      #Variables de proceso en sp.symbols
#X_salida = sp.symbols ('X_salida')              #Concentración células esporuladas


#Y = sp.Matrix([Xv, Xs, S, DO2])                 #Matriz con esas variables de proceso
#ff =sp.Matrix([dXv_dt, dXs_dt, dSdt, dCDO_dt])  #Matriz con las ecuaciones diferenciales


u= sp.Matrix([Xv, Xs, S, DO2])                 #Matriz u para las variables de entrada
x_s = sp.Matrix([Xv_o, Xs_o, S_o, DO2_o])      #Matriz x_s para las variables de estado


#A partir de esto, calculamos el Jacobiano de la matriz ff para cada uno, es decir la matriz:
A = ff.jacobian(dXv_dt, dXs_dt, dSdt, dCDO_dt) #jacobiano de todas las ecuaciones respecto a las variables de *estado*

#-----------------------------------------------------------------------------------------
#La matriz B = ff.jacobian(u)  jacobiano de todas las ecuaciones respecto a las variables de *entrada*
3. Jacobiano de las variables de salida respecto a cada una de ellas:
C = Y.jacobian(x_s)
D = Y.jacobian(u)

"""#Tercer intento#"""

import sympy as sp
from sympy import init_printing
from IPython.display import display, Math

# -------------------------
# VARIABLES DE ESTADO
# -------------------------
Xv, Xs, S, DO2 = sp.symbols("Xv Xs S DO2")     # Estados
Y = sp.Matrix([Xv, Xs, S, DO2])                # Vector de estado

# -------------------------
# VARIABLE DE SALIDA (AHORA ES u = F_air_in)
# -------------------------
F_air_in = sp.symbols("F_air_in")              # Salida del sistema
u = sp.Matrix([F_air_in])                      # Vector de salida

# -------------------------
# VARIABLES DE ENTRADA (condiciones iniciales)
# -------------------------
Xv_o, Xs_o, S_o, DO2_o = sp.symbols("Xv_o Xs_o S_o DO2_o")  # Entradas
x_input = sp.Matrix([Xv_o, Xs_o, S_o, DO2_o])               # Vector de entrada

# -------------------------
# PARÁMETROS DEL MODELO
# -------------------------
mu_max, Yxs, ms = sp.symbols("mu_max Yxs ms")
Ks_max, Gs, Ps = sp.symbols("Ks_max Gs Ps")
Ke_max, Ge, Pe, t_0 = sp.symbols("Ke_max Ge Pe t_0")
Ko, K1, K2, K3 = sp.symbols("Ko K1 K2 K3")

# -------------------------
# FUNCIONES DEL MODELO
# -------------------------
mu = mu_max * (S / (Ks_max + S)) * (DO2 / (Ko + DO2))

Ks_expr = Ks_max * (1 / (1 + sp.exp(Gs * (S - Ps)))) - Ks_max * (1 / (1 + sp.exp(Gs * (S_o - Ps))))
Ke_expr = Ke_max * (1 / (1 + sp.exp(Ge * (Pe - Pe)))) - Ke_max * (1 / (1 + sp.exp(Ge * (t_0 - Pe))))

dXv_dt = (mu - Ks_expr - Ke_expr) * Xv
dXs_dt = Ks_expr * Xv
dS_dt = -((mu / Yxs) + ms) * Xv

OTR = K3 * F_air_in * (DO2_o - DO2)
OUR = K1 * (mu - Ke_expr) * Xv + K2 * (Xv + Xs)
dDO2_dt = OTR - OUR

ff = sp.Matrix([dXv_dt, dXs_dt, dS_dt, dDO2_dt])  # Sistema dinámico

# -------------------------
# MATRICES JACOBIANAS
# -------------------------
A = ff.jacobian(Y)         # Estados
B = ff.jacobian(x_input)   # Entradas
C = u.jacobian(Y)          # Salida respecto a estados
D = u.jacobian(x_input)    # Salida respecto a entradas

# -------------------------
# MOSTRAR MATRICES EN FORMATO LATEX
# -------------------------
init_printing(use_latex=True)

display(Math("A = " + sp.latex(A)))
display(Math("B = " + sp.latex(B)))
display(Math("C = " + sp.latex(C)))
display(Math("D = " + sp.latex(D)))

"""#2) 2.1 Matrices A,B,C y D y valores propios de la matriz A


"""

import numpy as np

# Parámetros del proceso
F_air_in = 1320  # [L/h]
DO2_sat = 7.59e-3  # [g O2/L]
K1 = 3.795e-3
K2 = 0.729e-3
K3 = 2.114e-3
V = 11
Ko = 1e-4

# Condiciones iniciales
Xv_o = 1
Xs_o = 0
S_o = 32
DO2_o = 7.4e-3

# Parámetros adicionales
mu_max = 0.65
Yxs = 0.37
Ks = 3
ms = 0.005
Ks_max = 0.5
Gs = 1
Ps = 1
Ke_max = 0.1
Ge = 5
Pe = 4.9

# Valores de las variables en estado estacionario
Xv_ee = 4.9629
Xs_ee = 10.0216
S_ee = 0
DO2_ee = 0.003083

# Derivadas parciales de las ecuaciones diferenciales (Jacobiano)
def calcular_derivadas_parciales(Xv, Xs, S, CDO, u):
    # Ecuación 1: dXv/dt = (u - Ks - Ke) * Xv
    dXv_dXv = u - Ks - Ke_max  # Derivada con respecto a Xv
    dXv_dXs = 0  # No depende de Xs
    dXv_dS = -Ks * Xv  # Derivada con respecto a S
    dXv_dDO2 = 0  # No depende de DO2

    # Ecuación 2: dXs/dt = Ks * Xv
    dXs_dXv = Ks  # Derivada con respecto a Xv
    dXs_dXs = 0  # No depende de Xs
    dXs_dS = 0  # No depende de S
    dXs_dDO2 = 0  # No depende de DO2

    # Ecuación 3: dS/dt = -(u/Yxs + ms) * Xv
    dS_dXv = -((u / Yxs) + ms) * Xv  # Derivada con respecto a Xv
    dS_dXs = 0  # No depende de Xs
    dS_dS = 0  # No depende de S
    dS_dDO2 = 0  # No depende de DO2

    # Ecuación 4: dDO2/dt = OTR - OUT
    OTR = K3 * F_air_in * (DO2_sat - CDO)
    OUT = K1 * (u - Ke_max) * Xv + K2 * (Xv + Xs)
    dDO2_dXv = -K1 * (u - Ke_max) - K2  # Derivada con respecto a Xv
    dDO2_dXs = -K2  # Derivada con respecto a Xs
    dDO2_dS = 0  # No depende de S
    dDO2_dDO2 = K3 * F_air_in  # Derivada con respecto a DO2

    # Matriz A (Jacobian de los estados)
    A = np.array([
        [dXv_dXv, dXv_dXs, dXv_dS, dXv_dDO2],
        [dXs_dXv, dXs_dXs, dXs_dS, dXs_dDO2],
        [dS_dXv, dS_dXs, dS_dS, dS_dDO2],
        [dDO2_dXv, dDO2_dXs, dDO2_dS, dDO2_dDO2]
    ])

    # Derivadas parciales con respecto a la entrada (u)
    dXv_du = Xv  # Derivada de Xv con respecto a u
    dXs_du = 0  # No depende de u
    dS_du = 0  # No depende de u
    dDO2_du = K1 * (Xv)  # Derivada de DO2 con respecto a u

    # Matriz B (derivadas con respecto a la entrada)
    B = np.array([
        [dXv_du],
        [dXs_du],
        [dS_du],
        [dDO2_du]
    ])

    # Matriz C (identidad 4x4, como se especificó)
    C = np.eye(4)  # Matriz identidad 4x4

    # Matriz D (transmisión directa, asumida como cero)
    D = np.array([[0]])

    return A, B, C, D

# Llamo la función para obtener las matrices A, B, C, y D en el punto de equilibrio
A, B, C, D = calcular_derivadas_parciales(Xv_ee, Xs_ee, S_ee, DO2_ee, F_air_in)

# Función para imprimir las matrices de manera adecuada
def imprimir_matriz(nombre, matriz):
    print(f"{nombre} = ")
    filas, columnas = matriz.shape
    for i in range(filas):
        print(f"[{', '.join([f'{x:.6e}' for x in matriz[i]])}]")
    print()

# Calcular los valores propios (autovalores) de la matriz A
valores_propios, _ = np.linalg.eig(A)

# Mostrar los valores propios
print("Valores propios de la matriz A:")
print(valores_propios)
print()

# Imprimir las matrices A, B, C y D
imprimir_matriz("A", A)
imprimir_matriz("B", B)
imprimir_matriz("C", C)
imprimir_matriz("D", D)

"""#Variables linealizadas#"""

import numpy as np

# Parámetros del proceso
F_air_in = 1320  # [L/h]
DO2_sat = 7.59e-3  # [g O2/L]
K1 = 3.795e-3
K2 = 0.729e-3
K3 = 2.114e-3
V = 11
Ko = 1e-4

# Valores de las variables en estado estacionario
Xv_ee = 4.9629
Xs_ee = 10.0216
S_ee = 0
DO2_ee = 0.003083

# Parámetros adicionales
mu_max = 0.65
Yxs = 0.37
Ks = 3
ms = 0.005
Ks_max = 0.5
Gs = 1
Ps = 1
Ke_max = 0.1
Ge = 5
Pe = 4.9

# Derivadas parciales de las ecuaciones diferenciales (Jacobiano)
def calcular_derivadas_parciales(Xv, Xs, S, CDO, u):
    # Ecuación 1: dXv/dt = (u - Ks - Ke) * Xv
    dXv_dXv = u - Ks - Ke_max  # Derivada con respecto a Xv
    dXv_dXs = 0  # No depende de Xs
    dXv_dS = -Ks * Xv  # Derivada con respecto a S
    dXv_dDO2 = 0  # No depende de DO2

    # Ecuación 2: dXs/dt = Ks * Xv
    dXs_dXv = Ks  # Derivada con respecto a Xv
    dXs_dXs = 0  # No depende de Xs
    dXs_dS = 0  # No depende de S
    dXs_dDO2 = 0  # No depende de DO2

    # Ecuación 3: dS/dt = -(u/Yxs + ms) * Xv
    dS_dXv = -((u / Yxs) + ms) * Xv  # Derivada con respecto a Xv
    dS_dXs = 0  # No depende de Xs
    dS_dS = 0  # No depende de S
    dS_dDO2 = 0  # No depende de DO2

    # Ecuación 4: dDO2/dt = OTR - OUT
    OTR = K3 * F_air_in * (DO2_sat - CDO)
    OUT = K1 * (u - Ke_max) * Xv + K2 * (Xv + Xs)
    dDO2_dXv = -K1 * (u - Ke_max) - K2  # Derivada con respecto a Xv
    dDO2_dXs = -K2  # Derivada con respecto a Xs
    dDO2_dS = 0  # No depende de S
    dDO2_dDO2 = K3 * F_air_in  # Derivada con respecto a DO2

    # Matriz A
    A = np.array([
        [dXv_dXv, dXv_dXs, dXv_dS, dXv_dDO2],
        [dXs_dXv, dXs_dXs, dXs_dS, dXs_dDO2],
        [dS_dXv, dS_dXs, dS_dS, dS_dDO2],
        [dDO2_dXv, dDO2_dXs, dDO2_dS, dDO2_dDO2]
    ])

    #Matriz B
    B = np.array([[4.962900e+00], [0.000000e+00], [0.000000e+00], [1.883421e-02]])

    return A, B

# Llamo a la función para obtener las matrices A y B
A, B = calcular_derivadas_parciales(Xv_ee, Xs_ee, S_ee, DO2_ee, F_air_in)

# Función para imprimir las ecuaciones linealizadas, omitiendo términos cero
def imprimir_ecuaciones_linealizadas(A, B):
    print("Ecuaciones linealizadas:")

    # Ecuación de dXv/dt
    eq1 = f"dxv(t)/dt = "
    if A[0, 0] != 0: eq1 += f"{A[0, 0]:.6e} * Xvlin "
    if A[0, 1] != 0: eq1 += f"+ {A[0, 1]:.6e} * Xslin "
    if A[0, 2] != 0: eq1 += f"+ {A[0, 2]:.6e} * Slin "
    if A[0, 3] != 0: eq1 += f"+ {A[0, 3]:.6e} * CODlin"
    print(eq1)

    # Ecuación de dXs/dt
    eq2 = f"dxs(t)/dt = "
    if A[1, 0] != 0: eq2 += f"{A[1, 0]:.6e} * Xvlin "
    if A[1, 1] != 0: eq2 += f"+ {A[1, 1]:.6e} * Xslin "
    if A[1, 2] != 0: eq2 += f"+ {A[1, 2]:.6e} * Slin "
    if A[1, 3] != 0: eq2 += f"+ {A[1, 3]:.6e} * CODlin"
    print(eq2)

    # Ecuación de dS/dt
    eq3 = f"ds(t)/dt = "
    if A[2, 0] != 0: eq3 += f"{A[2, 0]:.6e} * Xvlin "
    if A[2, 1] != 0: eq3 += f"+ {A[2, 1]:.6e} * Xslin "
    if A[2, 2] != 0: eq3 += f"+ {A[2, 2]:.6e} * Slin "
    if A[2, 3] != 0: eq3 += f"+ {A[2, 3]:.6e} * CODlin"
    print(eq3)

    # Ecuación de d(CDO)/dt
    eq4 = f"d(CDO(t))/dt = "
    if A[3, 0] != 0: eq4 += f"{A[3, 0]:.6e} * Xvlin "
    if A[3, 1] != 0: eq4 += f"+ {A[3, 1]:.6e} * Xslin "
    if A[3, 2] != 0: eq4 += f"+ {A[3, 2]:.6e} * Slin "
    if A[3, 3] != 0: eq4 += f"+ {A[3, 3]:.6e} * CODlin"
    print(eq4)


imprimir_ecuaciones_linealizadas(A, B)

"""#2.4  Función de transferencia de las ecuaciones en espacio de estados"""

!pip install control

import numpy as np
import control as ctrl  # Asegúrate de que la librería control esté instalada

#Parámetros del proceso
F_air_in = 1320  # [L/h]
DO2_sat = 7.59e-3  # [g O2/L]
K1 = 3.795e-3
K2 = 0.729e-3
K3 = 2.114e-3
V = 11
Ko = 1e-4

# Condiciones iniciales
Xv_o = 1
Xs_o = 0
S_o = 32
DO2_o = 7.4e-3

# Parámetros adicionales
mu_max = 0.65
Yxs = 0.37
Ks = 3
ms = 0.005
Ks_max = 0.5
Gs = 1
Ps = 1
Ke_max = 0.1
Ge = 5
Pe = 4.9

# Valores de las variables en estado estacionario
Xv_ee = 4.9629
Xs_ee = 10.0216
S_ee = 0
DO2_ee = 0.003083

# Derivadas parciales de las ecuaciones diferenciales (Jacobiano)
def calcular_derivadas_parciales(Xv, Xs, S, CDO, u):
    # Ecuación 1: dXv/dt = (u - Ks - Ke) * Xv
    dXv_dXv = u - Ks - Ke_max  # Derivada con respecto a Xv
    dXv_dXs = 0  # No depende de Xs
    dXv_dS = -Ks * Xv  # Derivada con respecto a S
    dXv_dDO2 = 0  # No depende de DO2

    # Ecuación 2: dXs/dt = Ks * Xv
    dXs_dXv = Ks  # Derivada con respecto a Xv
    dXs_dXs = 0  # No depende de Xs
    dXs_dS = 0  # No depende de S
    dXs_dDO2 = 0  # No depende de DO2

    # Ecuación 3: dS/dt = -(u/Yxs + ms) * Xv
    dS_dXv = -((u / Yxs) + ms) * Xv  # Derivada con respecto a Xv
    dS_dXs = 0  # No depende de Xs
    dS_dS = 0  # No depende de S
    dS_dDO2 = 0  # No depende de DO2

    # Ecuación 4: dDO2/dt = OTR - OUT
    OTR = K3 * F_air_in * (DO2_sat - CDO)
    OUT = K1 * (u - Ke_max) * Xv + K2 * (Xv + Xs)
    dDO2_dXv = -K1 * (u - Ke_max) - K2  # Derivada con respecto a Xv
    dDO2_dXs = -K2  # Derivada con respecto a Xs
    dDO2_dS = 0  # No depende de S
    dDO2_dDO2 = K3 * F_air_in  # Derivada con respecto a DO2

    # Matriz A
    A = np.array([
        [dXv_dXv, dXv_dXs, dXv_dS, dXv_dDO2],
        [dXs_dXv, dXs_dXs, dXs_dS, dXs_dDO2],
        [dS_dXv, dS_dXs, dS_dS, dS_dDO2],
        [dDO2_dXv, dDO2_dXs, dDO2_dS, dDO2_dDO2]
    ])

    # Derivadas parciales con respecto a la entrada (u)
    dXv_du = Xv  # Derivada de Xv con respecto a u
    dXs_du = 0  # No depende de u
    dS_du = 0  # No depende de u
    dDO2_du = K1 * (Xv)  # Derivada de DO2 con respecto a u

    # Matriz B (derivadas con respecto a la entrada)
    B = np.array([
        [dXv_du],
        [dXs_du],
        [dS_du],
        [dDO2_du]
    ])

    # Matriz C
    C = np.eye(4)[3, :].reshape(1, 4)

    # Matriz D
    D = np.zeros((1, 1))

    return A, B, C, D

# Llamo la función para obtener las matrices A, B, C, y D en el punto de equilibrio
A, B, C, D = calcular_derivadas_parciales(Xv_ee, Xs_ee, S_ee, DO2_ee, F_air_in)

# Crear el sistema de espacio de estados
sys_ss = ctrl.ss(A, B, C, D)

# Obtener la función de transferencia
sys_tf = ctrl.ss2tf(sys_ss)

# Mostrar la función de transferencia
print("Función de transferencia del sistema (Input: F_air_in, Output: DO2):")
print(sys_tf)


# Obtener el denominador de la función de transferencia
denominador = sys_tf.den[0]

# Convertir el denominador a un arreglo unidimensional y aplanar si necesario
denominador_array = np.asarray(denominador).flatten()


# Obtener las raíces del denominador
ceros_denominador = np.roots(denominador_array)

# Mostrar los ceros del denominador (raíces del polinomio característico)
print("\nCeros del denominador (raíces del polinomio característico):")
print(ceros_denominador)

# Analizar la estabilidad
estabilidad = "Estable"
for raiz in ceros_denominador:
    if np.real(raiz) > 0:
        estabilidad = "Inestable"
        break
    elif np.real(raiz) == 0:
        estabilidad = "Neutro"
        break

print(f"\nEl sistema es: {estabilidad}")